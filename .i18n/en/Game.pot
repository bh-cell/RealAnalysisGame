msgid ""
msgstr "Project-Id-Version: Game v4.23.0-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Prove the \\\"Archimedean Property\\\"\n"
"that no matter how small `Îµ > 0` may be,\n"
"there is always a natural number `N` with `1 / Îµ < N`."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "Did you end up using `huv`?\n"
"And then `specialize`ing it with `u` and `v` replaced, respectively, by `x` and `y`?\n"
"Or did you think of going via the more direct route:\n"
"`have hxy : (x + y) ^ 2 = (x ^ 2 + y ^ 2) + 2 * (x * y) := by ring_nf`?"
msgstr ""

#: Game.Levels.L3Lecture
msgid "Lecture 3: More fun with Sequences"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "The `linarith` tactic, with syntax `linarith [hâ‚, hâ‚‚]`, can solve goals that are linear arithmetic combinations of hypotheses `hâ‚, hâ‚‚` involving `â‰¤`, `<`, `=` with addition and multiplication by constants."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "This is a good time to record the fact that `1 / Îµ â‰¤ âŒˆ1 / ÎµâŒ‰â‚Š`.\n"
"You can do that with: `have fact : 1 / Îµ â‰¤ âŒˆ1 / ÎµâŒ‰â‚Š := by bound`. The `bound` tactic can solve inequalities like this."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "The `field_simp` tactic tries to clear denominators, if it can figure out that the denominators are non-zero (or in the case of inequalities, positive)."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ðŸŽ‰"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "You might think that the `bound` tactic\n"
"would also be able to solve `1 / Îµ < â†‘(âŒˆ1 / ÎµâŒ‰â‚Š + 1)`, but No!\n"
"That's because the addition `âŒˆ1 / ÎµâŒ‰â‚Š + 1` happens as **natural numbers**, and only then is the result cast to the reals; so the\n"
"`fact` that was just proved is not useful to `bound`. Instead try: `push_cast` to get the casting to push down as far as possible.\n"
"The Goal will change to `1 / Îµ < â†‘âŒˆ1 / ÎµâŒ‰â‚Š + 1`, where now the\n"
"ceiling is cast to the reals, and then the real number `1` is added."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The `use` tactic provides a specific value to prove an existence statement."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Write `specialize hf t` to apply the universal statement to the specific value t."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "If you're stuck at this point, let me remind you that, in a previous level, the Goal was: `âˆ€ Îµ > 0, BlahBlah`, and\n"
"after `intro Îµ`, the Goal became `Îµ > 0 â†’ BlahBlah`.\n"
"Then what did you do?..."
msgstr ""

#: Game
msgid "Learn real analysis through the historical crises that forced mathematicians to rebuild calculus from the ground up in the 19th century."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "# A Great Debate\n"
"\n"
"In the 19th century, when people were still confused about limits in general, there was a specific sequence that they fought over:\n"
"\n"
"1, -1, 1, -1, 1, -1, ...\n"
"\n"
"Does this converge or not???\n"
"\n"
"Some people said, well, you go up one then down one, so on average, it's around zero. So the limit should be 0.\n"
"\n"
"Other people said: look at the partial sums of the sequence:\n"
"\n"
"1 = 1\n"
"\n"
"1 + (-1) = 0\n"
"\n"
"1 + (-1) + 1 = 1\n"
"\n"
"1 + (-1) + 1 + (-1) = 0\n"
"\n"
"Ah so the partial sums alternate between 1 and 0, so maybe the limit is 1/2!\n"
"\n"
"This is the kind of trouble you get into if you don't have a community consensus on what the definitions of things are, namely, if you don't have a rigorous definition of limit. Luckily, we now do!\n"
"\n"
"With that definition, this sequence .... does not have a limit (\"diverges\").\n"
"\n"
"In order to express that formally, let's make a new definition:\n"
"\n"
"`def SeqConv (a : â„• â†’ â„) : Prop := âˆƒ L, SeqLim a L`\n"
"\n"
"That is, a sequence `a` \"converges\" (without specifying to what), if there indeed exists some real number `L`\n"
"so that `a` converges to that number.\n"
"\n"
"In this level, then, our goal is to prove:\n"
"\n"
"`Goal : Â¬ SeqConv a`,\n"
"\n"
"given the assumption `ha : âˆ€ n, a n = (-1 : â„) ^ n`. (Note that the \"not\" symbol, `Â¬`, is obtained by typing\n"
"`\\not`.)\n"
"\n"
"How do you prove the negation of something? Logically speaking, you would say, well, if that thing did happen, then we'd have a contradiction. Technically, `Â¬ P` is definitionally equivalent to: `P â†’ False`.\n"
"\n"
"So we could start our proof by reminding ourselves of this fact, by typing:\n"
"\n"
"`change SeqConv a â†’ False`\n"
"\n"
"That will change the Goal to: `SeqConv a â†’ False`.\n"
"\n"
"In general, I would recommend the following protocol:\n"
"\n"
"1) Think. Do scratchwork, get a vague sense of how to piece the argument together.\n"
"\n"
"2) Then prove it formally. You're NOT done! Just because you proved it formally doesn't *necessarily* mean that you really understand what's going on! The goal of mathematics is *not* that it just works, but rather that you **understand** exactly what's going on. So step 3 is:\n"
"\n"
"3) Give a natural language proof that explains (to yourself, as much as to anyone else, including me) what's going on and why.\n"
"\n"
"Using only knee jerk reactions (if you see `P â†’ Q` in the Goal, write `intro`. If you see `âˆƒ` in a hypothesis, write `choose`. If you see a definition in the Goal or a hypothesis, write `change`), we got as far as:\n"
"\n"
"**Objects:** `a : â„• â†’ â„`, `L : â„`\n"
"\n"
"**Assumptions:** `ha : âˆ€ (n : â„•), a n = (-1) ^ n`, `hL : âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, |a n - L| < Îµ`\n"
"\n"
"**Goal:** `False`\n"
"\n"
"Remember the Engineer and Mechanic: the Engineer gets to specify any tolerance, and the Mechanic has to guarantee that we'll be within that tolerance \"eventually\", that is, for all large enough `n`, as measured by the lower bound `N`.\n"
"\n"
"**Key Idea:** Find an `Îµ` that is too tight a tolerance, and the Mechanic will never be able to get within that specification. Because the sequence alternates between `1` and `-1`, which differ by `2`, the tolerance `Îµ = 1` would already be enough, but just to be safe, let's give ourselves a little more room, and set `Îµ = 1/2`.\n"
"\n"
"Note: Had we set `Îµ = 1.5`, that would *not* work. We can't rule out the possibility that `L= 0`, and both values `1` and `-1` *are* indeed within that tolerance. So we won't find a contradiction that way.\n"
"\n"
"\n"
"After a bunch of computation, we reached the following:\n"
"\n"
"`|1 - L| < 1/2`\n"
"\n"
"and\n"
"\n"
"`|-1 - L| < 1/2`\n"
"\n"
"Let's try to come up with a contradiction from that.\n"
"\n"
"`2 = |2| = |1 - (-1)| = |(1 - L) + (L - (-1))|`\n"
"\n"
"`â‰¤|(1 - L)| + |(L - (-1))| = |(1 - L)| + |-((-1) - L)|`\n"
"\n"
"`= |(1 - L)| + |((-1) - L)| < 1/2 + 1/2 = 1`\n"
"\n"
"And that get us the desired contradiction.\n"
"\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- **Negation**: If `P` is some `Prop`, then `Â¬ P` is definitionally equivalent to `P â†’ False`. So you can write `change P â†’ False`, either at the Goal, or `at` a hypothesis.\n"
"\n"
"\n"
"- **The triangle inequality**: To add the fact that `|x + y| â‰¤ |x| + |y|` to our list of hypotheses, invoke the `abs_add` theorem:\n"
"\n"
"`have factName : |x + y| â‰¤ |x| + |y| := by apply abs_add`\n"
"\n"
"- **Negation inside an absolute value**: You may also find useful the theorem `abs_neg`, which can be called via:\n"
"\n"
"`have factName : |-x| = |x| := by apply abs_neg`\n"
"\n"
"Warning! Make sure the pattern `|-Something|` is on the left hand side. If Lean doesn't see an absolute value\n"
"followed by a minus sign, `abs_neg` won't work!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "Write `choose c hc using h`, then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "Big Boss: The Ultimate Tactic Challenge"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Given `Îµ` and the fact that `0 < Îµ`, the theorem `ArchProp` claims the existence of `N : â„•` so that `1 / Îµ < N`. This is a formalization of the classical Archimedean Property."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# ðŸŽ‰ VICTORY! ðŸŽ‰\n"
"\n"
"You've defeated the Big Boss and mastered all the fundamental tactics of mathematical reasoning!\n"
"\n"
"**Let's see what you just accomplished:**\n"
"\n"
"1. **`choose a ha using h_existential`** - Extracted the witness `a` and fact that `f (a) = 3` from the hypothesis\n"
"2. **`use a`** - Chose `a` as your witness for the existence statement in the goal\n"
"3. **`intro y hy`** - Handled the universal quantifier \"for all y > 0\" in the goal\n"
"4. **`specialize h_universal y hy`** - Applied the universal property to your specific value in the hypothesis\n"
"5. **`rewrite [h_universal]`** - Used the specialized fact to rewrite the goal\n"
"6. **`rewrite [ha]`** - Used the original fact that `f (a) = 3` to also rewrite the goal\n"
"7. **`ring_nf`** - Verified finally that `(f y + 9) ^ 2 = (f y + 3 ^ 2) ^ 2`\n"
"\n"
"You've just completed a genuinely sophisticated mathematical argument! This kind of multi-step reasoning, combining existence statements, universal properties, and algebraic manipulation, is exactly what you'll encounter throughout real analysis.\n"
"\n"
"**You are now ready to begin your journey to rigorous calculus!**\n"
"\n"
"Welcome to the Introduction to Formal Real Analysis. ðŸŽ“\n"
"\n"
"**Epilogue**\n"
"\n"
"Before we continue with more Real Analysis and more Lean, letâ€™s pause to note a few interesting things about working formally.\n"
"Using a theorem prover interactively is (I hope) tremendously fun and (I hope) leads to rapid gains, immediate feedback, and clarity of thought.\n"
"\n"
"Imagine trying to learn chess by just reading through algebraic notation - 1.e4 e5 2.Nf3 Nf6 3.Bb5 a6 - sure, all the information is technically there, but isn't it so much easier to learn by actually looking at a chess board and seeing how the position changes after each move? In mathematics, it would be extraordinarily tedious to manually write on the blackboard the entire goal state after every move, keeping track of all the hypotheses and their relationships by hand. A theorem prover does this bookkeeping for you automatically, letting you focus on the mathematical content rather than the clerical work.\n"
"\n"
"But! This is, as we've already noted, a double-edged sword. We still want to train our brains to \"see\" a mental model of the goal state evolving - good chess players can visualize many moves ahead precisely because they've learned to maintain multiple mental game boards simultaneously. But until you develop that skill, and even after you have it, there's immense value in being able to instantly generate the current \"game board\" of your proof state. The immediate feedback helps you understand the consequences of each logical move, building the very intuition that will eventually let you work more independently. It's the difference between learning to navigate by always checking your GPS versus eventually developing an internal sense of direction - both have their place, and the former helps develop the latter."
msgstr ""

#: Game.Levels.L4Lecture
msgid "Lecture 4: Even more fun with Sequences"
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
msgid "# Problem 4\n"
"\n"
"This problem looks very similar to the previous one, but without a few hints, it\n"
"may cause great difficulty. The issue is that, last time, you likely called `specialize h1 0`, and turned `h1` into:\n"
"\n"
"`h1 : g (0 + 1) = g (0) + 3`\n"
"\n"
"If you do that now, the original `h1` will be *gone*, and you won't have a way of accessing it *again* to bootstrap from `g (1)` to `g (2)`. So what should you do?\n"
"\n"
"Observe that `have` can perform the same\n"
"role as `specialize` (and much more)! Try starting your solution with:\n"
"\n"
"`have h3 : g (0 + 1) = g (0) + 3 := by apply h1 0`\n"
"\n"
"This will not affect the original statement\n"
"of `h1`, but will instead add a *new* hypothesis, `h3`, which amounts to the\n"
"desired fact that `g (0 + 1) = g (0) + 3`.\n"
"Notice what's happening in the proof: `h1` says: for all `x`, `g (x + 1) = g (x) + 3`.\n"
"So `h1` is really a *function* whose input\n"
"is a real number `x`, and whose output is a\n"
"*proof* of the fact that, for this value of `x`, `g (x + 1) = g (x) + 3` holds. So when\n"
"we feed `0` into `h1`, it has the same effect\n"
"as it did when we `specialize`d, thus giving a proof of\n"
" exactly what was claimed in the `have` statement.\n"
"\n"
"Now you should be able to solve this problem."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The `rfl` tactic proves goals of the form `A = A` where both sides are *identical*."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ðŸŽ­"
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "# Problem Set 2\n"
"\n"
"This is problem set 2."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Now we need `1 / n < Îµ`. First establish that everything is positive. Start with: `have f3 : 0 < 1 / Îµ := by bound`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The intro tactic"
msgstr ""

#: Game.Levels.L3Pset.L3Pset2
msgid "# Problem 2\n"
"\n"
"Prove that the sequence `(n + 1) / n` has a limit, say, `L`, and determine what it is.\n"
"\n"
"We haven't yet learned a good way to use the theorem `OneOverNLimZero`\n"
"that we already proved, so just adapt the proof of that, rather than trying to quote it. (It's good practice!)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Great! You've learned the `specialize` tactic.\n"
"\n"
"Notice what happened:\n"
"1. Initially, `hf : âˆ€ x > 0, f (x) = x^2` was a universal statement\n"
"2. `specialize hf t` transformed it into `hf : t > 0 â†’ f (t) = t ^ 2`\n"
"3. Another `specialize` command, namely `specialize hf t_pos` turned the\n"
"hypothesis `hf` into `hf : f (t) = t ^ 2`\n"
"4. And finally, `apply hf` worked because the hypothesis matched the goal.\n"
"\n"
"The pattern is:\n"
"- `intro` when you have `âˆ€` in the goal (\"introduce an arbitrary term...\")\n"
"- `specialize` when you have `âˆ€` in a hypothesis (\"apply the hypothesis to specific value...\")\n"
"\n"
"This is fundamental in real analysis when working with:\n"
"- Function properties that hold \"for all x\"\n"
"- Limit definitions involving \"for all Îµ > 0\"\n"
"- Continuity statements\n"
"\n"
"Last lesson in Lecture 1 coming up."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Excellent! You've learned the `intro` tactic for universal statements.\n"
"\n"
"Notice what happened:\n"
"1. `intro Îµ` introduced the arbitrary real number Îµ\n"
"2. `intro hÎµ` introduced the hypothesis `hÎµ : Îµ > 0`\n"
"3. The goal became `(Îµ + 1)^2 = (Îµ + 1)^2`\n"
"4. `rfl` solved the goal, by the reflexive property of the equals sign.\n"
"\n"
"You might have noticed something interesting: we used `intro` in two seemingly different ways -- first to introduce an \"Object\" (the real number `Îµ`), and second to introduce an \"Assumption\" or hypothesis (that `Îµ > 0`). In Lean's underlying logic (\"dependent type theory\"), there's actually a deep unity here that mathematicians call the *Curry-Howard correspondence*: propositions are \"Types\", and proofs are \"Terms\" of those Types. This means that introducing a hypothesis is really just introducing a term of a certain type, just like introducing a variable.\n"
"\n"
"But here's an even more mind-bending perspective: our entire Statement is really a *function*! Its inputs are first an `Îµ : â„`, then a proof that `Îµ > 0`, and its output is a proof that `(Îµ + 1)^2 = (Îµ + 1)^2`. When we write `intro Îµ` and `intro h`, we're literally defining this function by saying \"given these inputs, here's how to compute the output.\" In this view, all of mathematics -- from the simplest definitions to proofs of the deepest theorems -- is secretly just **functions** transforming inputs into outputs!\n"
"\n"
"This beautiful connection between logic and computation underlies much of modern proof assistants, though we won't dive into the details in this course -- it's perfectly fine if you didn't follow the last two paragraphs! For now, just appreciate that `intro` works uniformly whether you're introducing mathematical objects or logical assumptions, and that every proof you write is secretly a program!\n"
"\n"
"The `intro` tactic is absolutely crucial in real analysis. You'll use it constantly to:\n"
"- Handle \"for all Îµ > 0\" statements in limit definitions\n"
"- Introduce arbitrary points in domain/range proofs\n"
"- Work with function definitions\n"
"\n"
"This pattern of `intro` followed by algebraic manipulation is everywhere in analysis!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# Level 1: The Main Definition\n"
"\n"
"Our first step to making Newton's argument rigorous is\n"
"to spell out *exactly* what we mean by a sequence\n"
"$a_n$ converging. It will take a little work to build up to the definition, and more importantly, *why*\n"
"that might seem like a reasonable definition to have.\n"
"\n"
"But first: for some reason (likely Euler is to blame), mathematics has *two* completely different conventions for how to write functions. For general functions $f : \\mathbb R \\to\\mathbb R$,\n"
"we write $f(x)$, with parentheses. But when work with sequences, $a_n$, meaning,\n"
"$a_0, a_1, a_2, \\dots$, we bizarely switch instead to subscripts.\n"
"Why? Historical accident.\n"
"A sequence is nothing but a function whose \"domain\" (that is, the set of\n"
"inputs to the function) is the natural numbers; so we will break\n"
"with tradition and unify the two conventions, henceforth writing\n"
"$a : \\mathbb N \\to \\mathbb R$ for sequences of real numbers, $a (0), a (1),\n"
"a (2), \\dots$.\n"
"\n"
"Now, the definition that mathematicians eventually came up with\n"
"for what it means for a sequence to converge, was so intricate (at least\n"
"at first sight) that it had to be invented *twice*!\n"
"The eventual formulation crystallized through the work of Karl Weierstrass in the 1860s, who transformed analysis from an intuitive art into a rigorous science. However, the seeds of this idea appeared much earlier in the work of Bernard Bolzano. In the 1810s and 1820s, Bolzano was developing remarkably modern ideas about continuity and limits, but he was too far ahead of his time for the mathematical community to accept these abstract concepts.\n"
"Only by Weierstrass's time -- a half-century later -- did these ideas catch on.\n"
"\n"
"Without further ado, here it is:\n"
"\n"
"Given a sequence `a : â„• â†’ â„` and a real number `L : â„`, we\n"
"write `lim a = L` and\n"
"say that the sequence `a` **converges** to `L`,\n"
" if:\n"
"\n"
"For every `Îµ > 0`, there exists `N : â„•` such that, for all `n â‰¥ N`, we have `|a (n) - L| < Îµ`.\n"
"\n"
"\n"
"This definition is probably not the first, or second, or tenth thing you might've come up with.\n"
"But over time, I hope you'll come to see that it\n"
" embodies a beautiful negotiation between precision and effort.\n"
"\n"
" I like to think of it as a conversation between an Engineer and a Machinist. The Engineer arrives with specifications: 'We're going to make this widget, and I need its length to be 1 foot, with an error tolerance\n"
" of 1/100 of an inch'. The Machinist replies: 'Sure, I can do that, but I'll have to run my special equipment for at least 10 hours to guarantee that tolerance.' The Enginner\n"
" replies: 'I'm sorry, I misspoke, can we change the tolerance\n"
" to 1/1000 of an inch?' The Machinist replies: 'Oof, yeah we can do it, but it'll cost ya. I'll need at least 40 hours of operation, but after that, I'll guarantee it.'\n"
"\n"
"As long as this conversation can continue regardless of *whatever* tolerance `Îµ > 0` the Engineer requires, with the Machinist\n"
"always being able to reply with a finite minimum number of hours `N`,\n"
"after which the tolerance will be achieved, we can say\n"
"that the equipment **converges**.\n"
"\n"
"Now let's read Weierstrauss's (or is it Bolzano's?) definition again. We have some process\n"
"that at time `n` returns a reading `a (n)` (think: widget length). Our ultimate goal is to make the length `L`. If\n"
"for any tolerance `Îµ > 0`, no matter how small, there will always exist some minimum\n"
"time `N`, so that, for any future time, `n â‰¥ N`,\n"
"we are guaranteed to be within that tolerance, `|a (n) - L| < Îµ`, that's exactly the condition under which we'll\n"
"say that the sequence `a (n)` **converges** to `L`.\n"
"\n"
"[![A Sequence Converging](images/SeqLim.jpg)](https://en.wikipedia.org/wiki/Limit_of_a_sequence)\n"
"\n"
"What makes this definition so powerful is its universality. The Machinist is essentially promising: 'Give me *any* tolerance requirement, no matter how stringent, and I can meet it -- though I might need more resources (larger `N`) for tighter specifications.'\n"
"\n"
"\n"
"Notice something else about the definition: It makes no mention of something happening \"eventually\", or \"at infinity\" or any other wishy-washy squirm words. We have traded the ambiguity of speaking about infinity for the precision of existential and universal quantifiers. No more hand-waving about what happens \"as `n` gets large\" - instead, we have a concrete challenge: given *any* tolerance `Îµ`, can you find a specific threshold `N`? *That* idea was the key breakthrough that allowed Calculus to enter the realm of rigorous mathematics.\n"
"\n"
"In Lean, the definition is written like so:\n"
"\n"
"`def SeqLim (a : â„• â†’ â„) (L : â„) : Prop :=\n"
"  âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, |a n - L| < Îµ`\n"
"\n"
"This syntax should be familiar from the `have` tactic you already know and love.\n"
"The special symbol `def` (instead of `have`) means that we're about to define something, and\n"
"`SeqLim` is its name (for squence limit, of course; but we could have called it whatever we want). Then our assumptions are a sequence `a : â„• â†’ â„` and\n"
"some real number `L : â„`. Then after the colon `:` goes our output, which in this case is `Prop`, that is, a statement (proposition) that can be true or false. So `SeqLim` is really a function that takes a sequence and hypothetical limiting value, and returns true or false based on whether\n"
"the condition is satisfied. Then comes a colon-equals `:=`, after which the\n"
"exact condition to be tested is specified. And the condition is what we already said, for all epsilon, yadda yadda. The big difference is that you can write `have` inside a proof, but you can't write `def` inside a proof;\n"
"`def` is reserved for making global definitions that\n"
"can be referenced forever once they're introduced.\n"
"Notice that on the right hand side, the list\n"
"of Definitions now includes `SeqLim`, and, as usual,\n"
"if you forget what it means, you can click on it for a reminder.\n"
"\n"
"Let's try out the definition in practice!\n"
"\n"
"**Your Task**\n"
"\n"
"Prove that the constant sequence converges to the same constant.\n"
"That is, suppose that you have a sequence `a : â„• â†’ â„`, and there's a real number\n"
"`L`, and a hypothesis that, for all values of `n`, we have  `a (n) = L`; then prove that `a` does converge, and converges to `L`. This is the simplest possible case: if our 'factory' always produces the exact target value `L`, then we can meet any tolerance requirement immediately!\n"
"\n"
"You may find useful a new tactic called `change`. It allows you to replace a goal (or hypothesis) by\n"
"something that is definitionally equal to it. In our example here,\n"
"You will see the goal as `SeqLim a L`. What are you supposed to do with that,\n"
"how can you make progress? Well, if you remember how `SeqLim` is defined,\n"
"then you can replace the goal with the definition, by writing\n"
"\n"
"`change âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, |a n - L| < Îµ`\n"
"\n"
"Lean will then change the goal to its definition.\n"
"Remember that `Îµ`, `N`, and `n` are all dummy variables\n"
"here, so you can have some fun:\n"
"\n"
"`change âˆ€ Alice > 0, âˆƒ Bob : â„•, âˆ€ blah â‰¥ Bob, |a blah - L| < Alice`\n"
"\n"
"This may come in handy later. (Not Alice and Bob *per se*, but the ability to give better names for dummy variables, so as not to clash with already existing variable names...)\n"
"\n"
"**âš ï¸âš ï¸âš ï¸ CAUTION âš ï¸âš ï¸âš ï¸** Remember how Lean *must* have space after a function name, it won't accept `f(x)` but instead requires `f (x)`? Well... it's the other way around for absolute\n"
"values. Lean won't accept a space after an absolute value.\n"
"So if you write `| a n - L|`, you'll get an error message.\n"
"Same with `|a n - L |` -- the space at the end is the problem. Sorry! I didn't write the syntax.\n"
"\n"
"**Normalizing Numerical Values**: And one last tactic you might also find useful is `norm_num` (for normalizing numerical values); it evaluates numerical expressions and proves equalities/inequalities involving concrete numbers. For example, if you're stuck with an `|0|` at some point,\n"
"and you want to convert it to plain old `0`, try calling `norm_num`.\n"
"\n"
"Ok, get to it!"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "And now the `bound` tactic will do the trick."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Write `rfl` since we're proving that something equals itself."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Try starting with `change âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, |a n - L| < Îµ`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The `intro` tactic introduces variables and hypotheses from âˆ€ statements or implications."
msgstr ""

#: Game.Levels.L4Lecture
msgid "# More on sequences"
msgstr ""

#: Game.Levels.L3Pset.L3Pset2
msgid "Prove that the sequence `(n + 1) / n` has a limit `L` and determine what it is."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Write `ring_nf` to expand and simplify both sides algebraically."
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L3Pset.L3Pset3
msgid "Problem 3"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Prove that the constant sequence converges to its constant value.\n"
"This is the Machinist's dream scenario: we're already producing exactly what's required!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "**BIG BOSS LEVEL**: This problem requires all the tactics you've learned!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "Lecture 2: Newton's Computation of Ï€"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The `specialize` tactic applies a universal statement in a hypothesis to a specific value."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "The `exact_mod_cast` tactic is similar to `apply`, except it automatically handles type coercions that would otherwise require manual casting."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "The `push_cast` tactic handles coercions between number types, particularly useful when working with natural numbers that need to be treated as real numbers (or integers, or rationals)."
msgstr ""

#: Game.Levels.L3PsetIntro
msgid "Pset 3"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "If there exists a point where f equals 2, then there exists a point where fÂ² equals 4."
msgstr ""

#: Game
msgid "# Welcome to Real Analysis, The Game!\n"
"\n"
"This course is currently being developed for Rutgers University Math 311H by [Alex Kontorovich](https://math.rutgers.edu/~alexk). Please email alex.kontorovich@rutgers.edu for suggestions/corrections,\n"
"or better yet, post a PR/issue to\n"
"https://github.com/AlexKontorovich/RealAnalysisGame.\n"
"\n"
"This course takes you through an Introduction to the Real Numbers, rigorous Îµ-Î´ Calculus,\n"
"and basic Point-Set Topology.\n"
"\n"
"To get started, click on\n"
"**\"Level 1: The Story of Real Analysis\"**, and good luck!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "# The Mathematical Revolution of 1666\n"
"\n"
"**SIMPLICIO:** I heard that Newton had a really cool way of calculating Ï€. Can you tell me about it?\n"
"\n"
"**SOCRATES:** Certainly. It begins around 1665-1666, when Newton was turning 23 years old. Anything significant about that year?\n"
"\n"
"**SIMPLICIO:** Isn't that Newton's  \"annus mirabilis\",  year of miracles? If I recall correctly, he was forced to leave Cambridge due to an outbreak of  the Great Plague, and made his most groundbreaking discoveries (calculus, optics, gravitation, etc) while quarantining in isolation at his family home in Woolsthorpe.\n"
"\n"
"**SOCRATES:** Exactly right. And one of the first things he discovered in that year was a  new version of\n"
"the Binomial Theorem. Tell me, please,  what can one say about\n"
"$(1 + x) ^ n$?\n"
"\n"
"**SIMPLICIO:** Sure thing, if you multiply $(1+x)^n$ all out, you get\n"
"$ \\binom{n}{0} + \\binom{n}{1}x + \\binom{n}{2}x^2 + \\cdots + \\binom{n}{n}x^n$. Here $\\binom{n}{k}$ is the \"binomial coefficient\", the number of ways of choosing $k$ things from a bag of $n$ things. Explicitly, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. These are just the numbers in Pascalâ€™s Triangle, and you can easily read off the $n$-th row.\n"
"[![Pascal's Triangle](images/Yanghui_triangle.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"\n"
"**SOCRATES:** Excellent! And do you know sigma notation?\n"
"\n"
"**SIMPLICIO:** I think so. I couldâ€™ve written  that same thing as $\\sum_{k=0}^{n} \\binom{n}{k} x^k$. In general, if you have some function $f: \\mathbb{N} \\to \\mathbb{R}$, and you want express $f(a)+f(a+1)+â€¦+f(b)$, that is, the sum of $f(k)$ as $k$ ranges from some integer $a$ up to some other integer $b$, you can write it as $\\sum_{k=a}^{b} f(k)$.\n"
"\n"
"**SOCRATES:** Very good.  So we have $(1+x)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^k$. Now, would you allow me to write this as a sum going all the way out to infinity?\n"
"$(1+x)^n = \\sum_{k=0}^{\\infty} \\binom{n}{k} x^k$\n"
"\n"
"**SIMPLICIO:** Hmm. Ok, I think I see what youâ€™re getting at: Pascalâ€™s Triangle has implied zeros everywhere outside, so $\\binom{n}{k}$ is just zero once $k>n$. So youâ€™ve written it as an infinite sum, even though it secretly terminates after finitely many terms. But what purpose does extending it serve?\n"
"\n"
"**SOCRATES:** Well, let me ask you this: can you think of any way of making sense of this formula when $n=-1$?\n"
"\n"
"**SIMPLICIO:** Huh? You canâ€™t use binomial coefficients. How do you choose 3 things from -1 things, that makes no sense!\n"
"\n"
"**SOCRATES:** Ok, sure, but so many great discoveries in mathematics occur when you realize a way to **break the rules**, and follow some pattern **past** its intended... limit (no pun intendedâ€¦). Put yourself in Newtonâ€™s shoes, if you can; what might a genius like him come up with?\n"
"\n"
"**SIMPLICIO:** Well, we do have this other formula for binomial coefficients, not in terms of combinatorics, but just as factorials, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. That still doesnâ€™t help because what the heck is $(-1)!$ supposed to be?! Oh, but wait! We can also write this as:\n"
"\n"
" $\\binom{n}{k} = \\frac{n(n-1)(n-2)\\cdots(n-k+1)}{k!}$\n"
"\n"
"And in this way, we â€œbypassâ€ the issue of dealing with $(-1)!$, and just go straight to â€œnormalâ€ numbers.\n"
"\n"
"**SOCRATES:** Can you please write this using product notation?\n"
"\n"
"**SIMPLICIO:** Sure, it's just like summation notation but with a $\\Pi$:\n"
"\n"
" $\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=1}^{k}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Whoops, are you sure about those bounds in the product?\n"
"\n"
"**SIMPLICIO:** Argh! It's so easy to make a silly mistake.\n"
"After writing down the formula, I should have\n"
"checked that I got the right start and end values;\n"
"the counter $\\ell$ should go from $0$ to $k-1$, not from $1$ to $k$.  Is this better?\n"
"\n"
"$\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Perfect. Go on.\n"
"\n"
"**SIMPLICIO:** Ok, so if we agree to follow this pattern, then we get:\n"
"\n"
"- $\\binom{-1}{0} = 1$, which makes sense because any row of Pascal's triangle starts with at $1=\\binom{c}{0}$; then\n"
"\n"
"- $\\binom{-1}{1} = (-1)/1! = -1$, which also makes sense because the next term in the \"$c$th row\" of Pascal's triangle is always\n"
"$\\binom{c}{1} = c$; then we get:\n"
"\n"
"- $\\binom{-1}{2} = (-1)(-2)/2! = +1$,\n"
"\n"
"- $\\binom{-1}{3} = (-1)(-2)(-3)/3!=-1$.\n"
"\n"
"Ok so I see the pattern:\n"
"it just alternates between $+1$ and $-1$, so the series goes:\n"
"\n"
" $(1+x)^{-1} = 1 - x + x^2 - x^3+x^4-x^5+\\cdots$.\n"
"\n"
"**SOCRATES:** Very good! But does this formula make any actual\n"
"*sense*? How might you test it?\n"
"\n"
"**SIMPLICIO:** Ok, if that series is supposed to \"represent\"\n"
"$1/(1+x)$, then if I multiply the whole thing by\n"
"$(1+x)$, I should just get $1$. Let's try it:\n"
"\n"
"$(1+x)(1 - x + x^2 - x^3+x^4-x^5+\\cdots) = ?$\n"
"\n"
"I'll first multiply everything by $1$, then by $x$, and add them all up.\n"
"\n"
"$(1 - x + x^2 - x^3+x^4-x^5+\\cdots) + (x - x^2 + x^3- x^4+x^5\\cdots)$\n"
"\n"
"Ok, so if I rearrange terms, then everything cancels out, and only the leading $1$ remains. Great!\n"
"\n"
"**SOCRATES:** Interesting. And are you \"allowed\" to rearrange terms like that?\n"
"\n"
"**SIMPLICIO:** Well.... why not?\n"
"\n"
"**SOCRATES:** Ok, nevermind that for now,\n"
"you seem to be satisfied that it makes sense to say\n"
"that the series\n"
"$1 - x + x^2 - x^3+x^4-x^5+\\cdots$ \"converges\" (again, whatever that means) to $(1+x)^{-1}$.\n"
"\n"
"**SIMPLICIO:** Come to think of it, I knew this already;\n"
"it's just the geometric series! I know that\n"
"\n"
"$1+\\lambda + \\lambda^2+\\lambda^3+\\cdots$\n"
"\n"
"adds up to $1/(1-\\lambda)$, and the series we have just replaces $\\lambda$ with $-x$.\n"
"\n"
"**SOCRATES:** Yes, very good.\n"
"And where might this \"belong\" in Pascalâ€™s triangle?\n"
"\n"
"**SIMPLICIO:**\n"
"Holy cow! Did we just discover an extension of the triangle, going â€œupâ€?!\n"
"[![Pascal's Triangle, Extended](images/PascalM1.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:**\n"
"Indeed, and we can in fact continue this pattern for $n=-2,\n"
"-3, -4,$ and so on. I'll let you work it out yourself, but we actually\n"
"get a *whole other* Pascal's triangle (with some negative signs) *above* the standard one!\n"
"[![Pascal's Triangle, Extended](images/PascalMn.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"See how it still follows the usual rule, that the two numbers above and to the left or right add to the value just below them?\n"
"\n"
"But let's try something even more exotic. Can you make\n"
"the Binomial Theorem work when $n=1/2$?\n"
"\n"
"\n"
"**SIMPLICIO:** Whoa, $n = 1/2$? That's... really pushing it! But let me try using the same formula. So $\\binom{1/2}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(1/2-\\ell)$. Let me work out the first few terms:\n"
"\n"
"- $\\binom{1/2}{0} = 1$ (as always)\n"
"\n"
"- $\\binom{1/2}{1} = (1/2)/1! = 1/2$ (again, matches the pattern we already knew)\n"
"\n"
"- $\\binom{1/2}{2} = (1/2)(-1/2)/2! = -1/8$\n"
"\n"
"- $\\binom{1/2}{3} = (1/2)(-1/2)(-3/2)/3! = 1/16$\n"
"\n"
"- $\\binom{1/2}{4} = \\frac{(1/2)(-1/2)(-3/2)(-5/2)}{4!} =  -\\frac{5}{128}$\n"
"\n"
"So $(1+x)^{1/2} = 1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots$\n"
"\n"
"But wait -- this is supposed to be $\\sqrt{1+x}$?!\n"
"\n"
"**SOCRATES:** Again, go into Newton's thinking: how might he go about justifying whether this formula makes any sense?\n"
"\n"
"**SIMPLICIO:** Oh, ok, I think I see! If we square the formula and multiply everything out, I guess we're supposed to get $1+x$ -- that would justify calling the series $\\sqrt{1+x}$.\n"
"\n"
"**SOCRATES:** Go for it!\n"
"\n"
"**SIMPLICIO:** Ok, so I want\n"
"\n"
"$\\left(1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots\\right)^2$\n"
"\n"
"That means squaring every term, and also adding twice every product of distinct pairs of terms.\n"
"\n"
"**SOCRATES:** Right. Can you think of a good way of keeping track of everything?\n"
"\n"
"**SIMPLICIO:** Oh, I know! Let's group things by the power of $x$ involved. The first one is easy: $x^0=1$, which you only get from squaring the first term. So that coefficient is $1$.\n"
"\n"
"For the coefficient of $x^1$, I can't square anything involving $x$'s, so I\n"
"can only multiply the $x$ term by the constant term, and of course double it.\n"
"That's just $2 \\times 1 \\times \\frac{1}{2}x = x$. So the coefficient of $x$ is $1$.\n"
"\n"
"For $x^2$, I get two contributions  from constant times quadratic: $2 \\times 1 \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{4}x^2$ and also from the square of the linear term: $\\left(\\frac{1}{2}x\\right)^2 = \\frac{1}{4}x^2$. So the total coefficient is $-\\frac{1}{4} + \\frac{1}{4} = 0$.\n"
"\n"
"Let's try a few more. To get $x^3$, I need:\n"
"- $2 \\times 1 \\times \\frac{1}{16}x^3 = \\frac{1}{8}x^3$ (constant times the $x^3$ term)\n"
"- $2 \\times \\frac{1}{2}x \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{8}x^3$ (the $x$ term times the $x^2$ term)\n"
"\n"
"So the total coefficient of $x^3$ is $\\frac{1}{8} - \\frac{1}{8} = 0$.\n"
"\n"
"This is amazing! It really seems like all the higher-order terms are canceling out perfectly. I bet that will keep happening, and we'll just get the square to come out to exactly $1+x$; the formula really works!\n"
"\n"
"So wait, now we get a whole other row in Pascal's triangle, *between* rows $0$ and $1$?!\n"
"\n"
"[![Pascal's Triangle](images/PascalM12.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:** Beautiful, isn't it!\n"
"\n"
"**SIMPLICIO:** Wait, this is all much simpler than I'm making it. Isn't this just the same thing as the Taylor expansion about $x=0$ of the function $f(x)=\\sqrt{1+x}$?\n"
"I already know how to do this from Calculus.\n"
"\n"
"**SOCRATES:** Yes, very good; but Brook Taylor (of Taylor series) did not prove his general theorem until 1715, a few decades after\n"
"Newton's computation of $\\pi$.\n"
"\n"
"Now, suppose you wanted to compute something like $\\sqrt 3$ -- can you think of a way of doing it using this formula?\n"
"\n"
"**SIMPLICIO:** Hmm the function is $\\sqrt {1+x}$, so I guess I want to set $x=2$. Then I get:\n"
"\n"
"$\\sqrt {1+2} = 1 + \\frac{1}{2}(2) - \\frac{1}{8}(2)^2 + \\frac{1}{16}(2)^3 -\n"
"\\frac{5}{128}(2)^4 + \\cdots$\n"
"\n"
"Adding up these five terms comes out to $11/8 = 1.375$, not so close to $\\sqrt3\\approx1.73$. And the individual terms\n"
"are not so small, for instance, the last one, $\\frac{5}{128}(2)^4 = 5/8 = 0.625$.\n"
"\n"
"**SOCRATES:** Well, sure, if you set $x$ to be large, like $x > 1$, then the powers of $x$ are also larger and larger (and exponentially so!)... Can you think of something else you could do?\n"
"\n"
"**SIMPLICIO:**\n"
"Ah, I think I see! I know that\n"
"$3$ is near $4$, which is a perfect square. So what if we write\n"
"\n"
"$\\sqrt 3 = \\sqrt{4-1} = \\sqrt{4(1-\\frac14)}=2\\sqrt{1-\\frac14}$\n"
"\n"
"So now if I apply our formula with $x=-1/4$ (which is less than one!), I guess I'll get:\n"
"\n"
"$\\sqrt3 \\approx 2\\left(\n"
"1 + \\frac{1}{2}(-1/4) - \\frac{1}{8}(-1/4)^2 + \\frac{1}{16}(-1/4)^3 -\n"
"\\frac{5}{128}(-1/4)^4+\\cdots\n"
"\\right)$\n"
"\n"
"Taking just these five terms, the fraction on the right comes out to $28379/16384\\approx 1.73212$, which is impressively close to $\\sqrt3\\approx1.7320508$.\n"
"We got 3 decimal places of accuracy, nice!\n"
"\n"
"**SOCRATES:** Great! Now you see the power of Newton's Binomial Theorem. Ok, so then let's return all the way back to your original question, about Newton's estimate for $\\pi$.\n"
"\n"
"**SIMPLICIO:** Hmmm, $\\pi$ is the ratio of circumference to diameter in a circle. So where am I supposed to find a length.\n"
"\n"
"**SOCRATES:** Ah, but what did we learn from Archimedes?\n"
"\n"
"**SIMPLICIO:** Oh, that $\\pi$ is also an *area*, not just a length. It's the area of a unit circle $\\pi r^2$ where $r=1$.\n"
"\n"
"**SOCRATES:** Beautiful. And could you find a circle's area lurking somewhere?\n"
"\n"
"**SIMPLICIO:**  I think I see it! Thanks to Descartes, and \"Cartesian\" coordinates, we can express the  circle as the graph of $x^2+y^2=1$, or to make it a function, $y=\\sqrt{1-x^2}$. So we just have to replace $x$ in our series with $-x^2$.\n"
"\n"
"$\n"
"\\sqrt{1-x^2}\n"
"= 1 + \\frac{1}{2}(-x^2) - \\frac{1}{8}(-x^2)^2 + \\frac{1}{16}(-x^2)^3 - \\frac{5}{128}(-x^2)^4+\\cdots\n"
"$\n"
"\n"
"$\n"
"= 1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\n"
"$\n"
"\n"
"And the area under the curve $y=\\sqrt{1-x^2}$ from $x=0$ to $x=1$ is\n"
"a quarter circle.\n"
"[![Quarter Circle](images/PiOver4.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"\n"
"**SOCRATES:** Luckily, Newton had just invented calculus! So how else\n"
"could he compute the area under this curve?\n"
"\n"
"**SIMPLICIO:** With an integral! So:\n"
"\n"
"$\\frac{\\pi}4 = \\int_0^1 \\sqrt{1-x^2} \\, dx =\n"
"\\int_0^1 \\left(1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\\right) dx$\n"
"\n"
"I'll just integrate term by term,...\n"
"\n"
"**SOCRATES:** Whoa, hang on! Why are you allowed... You know what, nevermind, sorry.\n"
"Just go ahead.\n"
"\n"
"**SIMPLICIO:** Ok, weirdo. Anyway. So integrating term by term, I get:\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"$= 1 - \\frac{1}{6} - \\frac{1}{40} - \\frac{1}{112} - \\frac{5}{1152} - \\cdots $\n"
"\n"
"Wow! So Newton got an infinite series for $\\pi$!\n"
"If I evaluate just these five terms, and cross multiply by the factor of $4$, I get the fraction\n"
"$32057/10080\\approx 3.180$, not bad!\n"
"\n"
"**SOCRATES:** Not bad indeed. You know, Simplicio, many math papers have roughly zero new ideas; they're just\n"
"doing something nobody bothered to do before in a slightly\n"
"newer context. A really good math paper can have one or two genuinely new ideas. Newton is already on new idea number five, and he's still not done!\n"
"\n"
"**SIMPLICIO:** Ok, so what's new idea number six?\n"
"\n"
"**SOCRATES:** Well, remember how you integrated all the way up to $x=1$? In your series,\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"you have all these high powers of $x$ but they're being \"wasted\" because you're setting $x$ to $1$. What if instead  you only integrated up to, say, $x=1/2$?\n"
"\n"
"**SIMPLICIO:** Ooh, cool! Then the series will converge much more rapidly. But wait, that changes the geometry. Instead of a quarter-circle, we now have... a 30 degree sector, which has area $\\pi/12$, plus a 30-60-90 triangle -- ah that must be why you suggested $x=1/2$ -- with area $\\frac12\\times\\frac12\\times\\frac{\\sqrt3}2$.\n"
"\n"
"[![Integrating to x=1/2](images/PiOver12.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"Good thing we already know how to quickly estimate $\\sqrt3$ to high accuracy! (Ah, that's the trade-off: we could set $x$ even smaller, for faster convergence, but then we'll need to deal with ever more complicated geometric evaluations; so $x=1/2$ is a \"sweet spot\".) So now:\n"
"\n"
" $ \\frac{\\pi}{12} +  \\frac{\\sqrt3}8 =\n"
"\\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^{1/2}$\n"
"\n"
"$ = \\frac12 - \\frac{1}{6}\\left(\\frac12\\right)^3 - \\frac{1}{40}\\left(\\frac12\\right)^5 - \\frac{1}{112}\\left(\\frac12\\right)^7 - \\frac{5}{1152}\\left(\\frac12\\right)^9 - \\cdots.$\n"
"\n"
"Again evaluating just these five terms already gives the fraction $9874097/20643840$.\n"
"And now isolating $\\pi$ gives the estimate\n"
"\n"
"$\\pi \\approx 12\\times\\left(9874097/20643840 -  \\frac{\\sqrt3}8\\right) \\approx 3.14161,$\n"
"\n"
"which is off by two parts in $100,000$ from the true estimate $\\pi \\approx 3.14159$. All that with just five terms, amazing!\n"
"\n"
"\n"
"**SOCRATES:** Yes, Newton was very impressive indeed.\n"
"Here's a nice YouTube video by Veritasium that discusses this whole saga (right-click to get it to pop up in a new tab):\n"
"[![Veritasium Video](https://img.youtube.com/vi/gMlf1ELvRzc/maxresdefault.jpg)](https://youtu.be/gMlf1ELvRzc)\n"
"\n"
" In fact, a series for $\\pi$ similar to this one was discovered two centuries earlier, by the Indian mathematician Madhava of Sangamagrama.\n"
" And it would take two more centuries until mathematicians figured out how to rigorously justify Newton's work. To do so, they had to figure out:\n"
"\n"
"- What it meant for a sequence of real numbers $a_0, a_1, a_2,\\dots$ to converge?\n"
"- What it meant for a series (that is, sequence of partial sums) $a_0 + a_1 + a_2 +\\cdots$ to converge, and could we sum these numbers in any order we like,\n"
"- What it meant for a series involving a variable, like a power series $a_0 + a_1  x + a_2  x^2+\\cdots$ to converge, and if so, what kind of function it converged to,\n"
"- When can we interchange limits with integrals, like integrating term by term, $\\int(a_0 + a_1  x + a_2  x^2+\\cdots)dx \\overset{?}=\\int \\, a_0\\, dx+\\int \\, a_1  x\\, dx+\\int\\, a_2  x^2\\, dx+\\cdots$,\n"
"\n"
"Etc, etc. We have a lot of work to do!\n"
"\n"
"**SIMPLICIO:** Ok, ok; you've convinced me! On with some actual Real Analysis please."
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
msgid "# Problem 1\n"
"\n"
"We found in Lecture 2 that Newton's Binomial Theorem gave the expansion\n"
"\n"
"$\n"
"\\sqrt{1+x}\\approx\n"
"1\n"
"+\\frac{1}{2}x\n"
"-\\frac{1}{8}x^2\n"
"+\\frac{1}{16}x^3\n"
"-\\frac{5 x^4}{128}+\\cdots\n"
"$\n"
"\n"
"to fourth order.\n"
"Work out the next term in the expansion. This will be a constant `c` with the property that the polynomial\n"
"\n"
"$\\left(1  +\\frac{1}{2}x\n"
"-\\frac{1}{8}x^2\n"
"+\\frac{1}{16}x^3\n"
"-\\frac{5 x^4}{128} + c \\cdot x^5 \\right)^2 - (1 + x)$\n"
"\n"
"only has terms $x ^ 6$ or higher. (We don't *yet* have a way of saying that in Lean, so I have to give you the expansion explicitly.)"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "As usual, compare to what's written in textbooks:\n"
"\n"
"## Natural Language Proof of `1 / n â†’ 0`\n"
"\n"
"**Theorem**: The sequence `a(n) = 1 / n` converges to `0`.\n"
"\n"
"**Proof**:\n"
"Let `Îµ > 0` be given. We need to find `N : â„•` such that for all `n â‰¥ N`, we have `|1 / n - 0| < Îµ`.\n"
"\n"
"Since `Îµ > 0`, we have `1 / Îµ > 0`. By the Archimedean Property, there exists a natural number `N` such that `1 / Îµ < N`. We choose this value of `N`, and use it.\n"
"\n"
"Now let `n â‰¥ N` be given. We need to show that `|1 / n| < Îµ`.\n"
"\n"
"Since `1 / Îµ < N` and `N â‰¤ n`, we have that `1 / Îµ < n`. Since both `1 / Îµ` and `n` are positive, taking reciprocals reverses the inequality: `1 / n < Îµ`.\n"
"\n"
"Therefore, `|1 / n - 0| = |1 / n| = 1 / n < Îµ`, which completes the proof. â–¡\n"
"\n"
"## What We Just Accomplished\n"
"\n"
"This proof demonstrates several key concepts:\n"
"\n"
"1. **The power of the Archimedean Property**: Without it, we couldn't guarantee the existence of a suitable `N`.\n"
"\n"
"2. **The `Îµ`-`N` definition in action**: We explicitly constructed `N` in terms of `Îµ`, showing the quantifier structure `âˆ€Îµ, âˆƒN, âˆ€n`.\n"
"\n"
"3. **Rigorous inequality manipulation**: What seems \"obvious\" requires careful attention to positivity and type casting.\n"
"\n"
"4. **The bridge between intuition and formality**: The intuitive idea that \"`1 / n` gets arbitrarily small\" becomes a precise mathematical statement."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Clear denominators in the goal: `field_simp`"
msgstr ""

#: Game.Levels.L3Pset.L3Pset1
msgid "Prove the full Archimedean Property."
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
msgid "# Problem 3\n"
"\n"
"You've just learned to add any necessary\n"
"auxiliary\n"
"facts to the list of hypotheses via the\n"
"`have` tactic.\n"
"In this problem,\n"
"you might find the following new idea useful.\n"
"\n"
"You already know that if you\n"
"have a hypothesis `h : X = Y`, and the Goal\n"
"contains `X`, then if you `rewrite [h]`,\n"
"then any instances of `X` in the goal\n"
"get replaced by `Y`.\n"
"But what if you have another hypothesis `h2`,\n"
"and you want to replace `X`'s in `h2` by `Y`s, what should you do then?\n"
"Elementary, my dear Watson!\n"
"You simply type:\n"
"\n"
"`rewrite [h] at h2`.\n"
"\n"
"So the syntax is `rewrite [h]` as before, then\n"
"the word `at`, and finally the name of the\n"
"hypothesis where you want the rewriting to happen.\n"
"Similarly, you can say `ring_nf at h2`,\n"
"and any algebra in hypothesis `h2` will be put into normal form.\n"
"\n"
"Now you should be able to solve this problem!"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "Pset 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Now write `specialize hf t_pos` feed in the proof that `t > 0`; then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Multiply the inequality `N â‰¤ n` by Îµ: `have f4 : N * Îµ â‰¤ n * Îµ := by bound`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "Excellent! You've learned the `choose` tactic for working with existence in hypotheses.\n"
"\n"
"Notice the complete pattern:\n"
"1. `choose c hc using h` unpacked the hypothesis into a specific value `c` and proof `hc : f c = 2`\n"
"2. `use c` provided this same value as our witness for the goal\n"
"3. `rewrite [hc]` rewrote `f c` as `2` in the goal, changing it to `2^2 = 4`\n"
"4. `ring_nf` verified that `2 ^ 2 = 4`\n"
"\n"
"The symmetry is beautiful:\n"
"- `use` when you have `âˆƒ` in the goal (\"here's my specific example\")\n"
"- `choose` when you have `âˆƒ` in a hypothesis (\"let me unpack this existence claim\")\n"
"\n"
"This completes your basic logical toolkit! In real analysis, you'll use `choose` constantly when working with:\n"
"- Limit definitions (\"given Îµ > 0, there exists Î´ > 0...\")\n"
"- Intermediate Value Theorem (\"there exists c such that f(c) = 0\")\n"
"- Existence theorems throughout analysis\n"
"\n"
"You're now ready to tackle real mathematical proofs!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `change` tactic changes a goal to something definitionally equal to it. If the definition of `X` is `Y`, that is, `X := Y`, and the Goal is `X`, you can write `change Y` and the Goal will change to `Y`. You can also\n"
"do this at a hypothesis; if you have a hypothesis `h : X`, you can write `change Y at h`, and `h` will change to `h : Y`."
msgstr ""

#: Game.Levels.L3Pset.L3Pset3
msgid "Determine what the limit of the sequence `1 / n ^ 2` is, and prove it."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Perfect! You've completed your first Lean proof involving real numbers.\n"
"\n"
"Remember: the `apply` tactic is used when you have what you need to prove the goal. Look at the top right: your list of tactics now includes `apply`, and if you forget how it works or what it does, just click on it for a reminder."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# The Final Challenge\n"
"\n"
"Congratulations! You've learned many fundamental tactics for mathematical reasoning in Lean:\n"
"- `apply hypothesisName` for when a hypothesis matches the goal\n"
"- `rfl` for reflexivity (proving `X = X`)\n"
"- `rewrite [hypothesisName]` for rewriting using equalities\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for providing witnesses to existence statements in goals\n"
"- `intro` for handling universal quantifiers in goals\n"
"- `specialize` for applying universal statements to specific values in hypotheses\n"
"- `choose value hypothesisOnValue using ExistentialHypothesis` for extracting information from existence statements in hypotheses\n"
"\n"
"Here's a little \"Universal/Existential Quantifier Cheat Sheet\":\n"
"\n"
"|           | âˆ€        | âˆƒ      |\n"
"|-----------|----------|--------|\n"
"| **Goal**  | `intro`    | `use`    |\n"
"| **Hypothesis** | `specialize` | `choose` |\n"
"\n"
"Now it's time for your first **Big Boss** - a problem that requires you to use almost ALL of these tactics in a single proof!\n"
"\n"
"**Lecture 1 Big Boss**\n"
"Given a function `f` and information about its behavior, prove a complex statement that involves existence, universals, algebra, and rewriting.\n"
"\n"
"This is what real mathematical proofs look like - a careful orchestration of multiple reasoning steps. You've got this! Use everything you've learned.\n"
"\n"
"**Extra Challenge**\n"
"If you want to *really* challenge yourself, play this level \"blind\". Write the assumptions and goal down on paper, close the computer, solve it by hand, keeping track *in your mind* of what happens to the game board after each command, and only once youâ€™ve worked it all out, open the computer and see if Lean accepts your solution.\n"
"\n"
"Why do you think that this would this be a good thing to do?\n"
"\n"
"In general, I hope your *goal* in taking this course is to make your \"Real Analysis Brain Muscles\" stronger. By the end, you should be *really good* at\n"
"solving Real Analysis problems on paper, where you don't have Lean showing\n"
"you the Goal State after every move.\n"
"More broadly, the purpose of learning to solve Real Analysis problems is to learn to *think*, clearly, precisely. Strengthening your ability to work with pen and paper (or just mentally) directly transfers to *any* other context where you're exploring ideas, wrestling with complicated arguments, or trying to communicate clearly to others.\n"
"\n"
"An LLM could easily work through all these Lean levels by pattern matching and logical manipulation - just as you could solve multiplication problems by plugging them into a calculator instead of memorizing your times tables. But that completely defeats the purpose of the exercise, which is to rewire your brain and build mathematical intuition. It's like deciding that you want to bench press 200 pounds, loading up the bar, and then using a forklift to lift it for you while you stand underneath - you might have moved the weight, but you haven't gotten any stronger. The real value isn't in producing correct proofs, it's in the cognitive transformation that happens when you *struggle* through the reasoning yourself, building the mental pathways that let you see mathematical structure intuitively."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "There exists a real number that makes this binomial expansion work."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "We need to find `N`. Use the Archimedean Property: there exists `N` such that `1 / Îµ < N`. Try: `have f1 : âˆƒ (N : â„•), 1 / Îµ < N := by apply ArchProp hÎµ`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "If you're struggling to prove that `2 ^ 2 = 4`, it's\n"
"a basic fact in a *ring*..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The use tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The `rewrite` tactic replaces the left-hand side of an equality with the right-hand side in the goal. The syntax is `rewrite [hypothesis_name1, hypothesis_name2, etc]`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Excellent! You've learned the `ring_nf` tactic.\n"
"\n"
"This tactic is incredibly powerful for algebraic manipulations. It automatically handles all the tedious algebra that would take many steps to do by hand.\n"
"\n"
"Your toolkit now includes:\n"
"- `apply hypothesis_name` for when a hypothesis matches your goal\n"
"- `rfl` for proving something equals itself\n"
"- `rewrite [hypothesis_name]` for rewriting using equalities\n"
"- `ring_nf` for algebraic simplifications and expansions\n"
"\n"
"As we move into real analysis proper, you'll find that `ring_nf` is invaluable for dealing with polynomial expressions, which appear everywhere in calculus!"
msgstr ""

#: Game.Levels.L3Pset.L3Pset4
msgid "# Problem 4\n"
"\n"
"Here's an even more involved limit problem. We've had luck getting `bound` to prove `|X| â‰¤ X`, especially when there's a hypothesis `h : 0 â‰¤ X` already available in the list of assumptions. But I've found it not to be reliable, unfortunately. So let me give you one more theorem for your toolchest.\n"
"\n"
"## New Theorem: `abs_of_nonneg`.\n"
"If you have a hypothesis `h : 0 â‰¤ X` in your toolchest,\n"
"then you can prove that `|X| = X` via:\n"
"\n"
"`have factName : |X| = X := by apply abs_of_nonneg h`."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Since 1 / Îµ < N, we get N > 0: `have Npos : (0 : â„) < N := by linarith [f3, eps_inv_lt_N]`. Again we need to be specific about the casting."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `norm_num` tactic can normalize numerical constants and functions of them."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For a sequence `a : â„• â†’ â„` and a real number `L : â„`, we say that `SeqLim a L` holds if: for every `Îµ > 0`, there exists `N : â„•` such that for all `n â‰¥ N`, we have `|a n - L| < Îµ`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The specialize tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Introduction to Lean"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "Show that there exists a constant `c` so that, for any real numbers `x` and `y` with `x ^ 2 + y ^ 2 = 2` and `x * y = 1`, we have `(x + y) ^ 2 = c`."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Archimedean Property"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Try `use âŒˆ1 / ÎµâŒ‰â‚Š + 1`. Of course you can use other values of `N`, but then I won't be able to give you more hints..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "The `choose` tactic extracts a witness from an existence statement in a hypothesis."
msgstr ""

#: Game
msgid "A First Course in Real Analysis"
msgstr ""

#: Game.Levels.L3PsetIntro
msgid "# Problem Set 3\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Let's compare now to the purely natural language proof:\n"
"\n"
"## Natural Language Proof of the Archimedean Property\n"
"\n"
"**Theorem**: For any positive real number Îµ > 0, there exists a natural number N such that 1 / Îµ < N.\n"
"\n"
"**Proof**:\n"
"Let Îµ > 0 be given. We need to find a natural number N such that 1 / Îµ < N.\n"
"\n"
"Use the value N = âŒˆ1 / ÎµâŒ‰â‚Š + 1, where âŒˆÂ·âŒ‰â‚Š denotes the natural number ceiling function.\n"
"\n"
"Since Îµ > 0, we have 1 / Îµ > 0. By the definition of the natural number ceiling function, we know that:\n"
"\n"
"1 / Îµ â‰¤ âŒˆ1 / ÎµâŒ‰â‚Š\n"
"\n"
"Now, since âŒˆ1 / ÎµâŒ‰â‚Š is a natural number and N = âŒˆ1 / ÎµâŒ‰â‚Š + 1, we have:\n"
"\n"
"âŒˆ1 / ÎµâŒ‰â‚Š < âŒˆ1 / ÎµâŒ‰â‚Š + 1 = N\n"
"\n"
"Combining these inequalities, we get that:\n"
"\n"
"1 / Îµ â‰¤ âŒˆ1 / ÎµâŒ‰â‚Š < N\n"
"\n"
"Therefore, 1 / Îµ < N, which completes the proof. â–¡\n"
"\n"
"**Significance**: The Archimedean Property is fundamental to analysis because it ensures that the real numbers have no \"infinite\" or \"infinitesimal\" elements. It guarantees that we can always find natural numbers large enough to dominate any given positive real number when we take their reciprocals. This property is essential for many limit processes and is equivalent to the completeness of the real numbers in certain formulations of real analysis.\n"
"\n"
"## Review of Common Pitfalls\n"
"\n"
"- **Don't use the regular ceiling function `âŒˆÂ·âŒ‰`** - it returns integers, not natural numbers!\n"
"- **Watch out for casting issues** - if `bound` isn't working, try `push_cast` first\n"
"- **The addition `âŒˆ1 / ÎµâŒ‰â‚Š + 1` happens in `â„•`**, then gets cast to `â„` - this is why we need `push_cast`\n"
"\n"
"**Historical Note**: While often attributed to Archimedes (c. 287-212 BCE), this property was likely known to Eudoxus (c. 408-355 BCE) and appears in Euclid's *Elements*. Archimedes used a version of this principle in his method of exhaustion, particularly in calculating areas and volumes by approximating them with polygons of increasing numbers of sides."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The rw tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "If we know that $x = 5$, then we can prove that $x = 5$."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Presumably you know that you\n"
"should `choose N hN using f1` at this stage. But maybe you'd like to give `hN` a more descriptive name (so that I can keep giving you hints). Try `choose N eps_inv_lt_N using f1`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "# When things are identical to themselves\n"
"\n"
"Sometimes in mathematics, we need to prove that something equals itself. For example, we might need to prove that $x^2 + 2y = x^2 + 2y$.\n"
"\n"
"This isn't quite the same as our previous exercise. There, we had a hypothesis `h` that told us `x = 5`, and we used `apply h` to prove the goal `x = 5`.\n"
"\n"
"But now we don't have any hypothesis that says `x^2 + 2y = x^2 + 2y`. We're just being asked to prove that some expression equals itself. We can't say `apply something` because there's no `something`.\n"
"\n"
"Instead, we will use what mathematicians call the *reflexive property* of equality: everything is equal to itself. In Lean, if you get to a situation where you're trying to prove an equality, and the two things on both sides are *identical*, then the syntax is to give the command `rfl` (short for \"reflexivity\").\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "The choose tactic"
msgstr ""

#: Game
msgid "*An Introduction to Formal Real Analysis - Interactive Edition*\n"
"\n"
"## About this Course\n"
"\n"
"This course follows the historical crises that forced mathematicians to rebuild\n"
"mathematics from the ground up in the 19th century. You'll learn why concepts\n"
"like Îµ-Î´ definitions became necessary and how to use them to do advanced calculus.\n"
"\n"
"## Credits\n"
"\n"
"* **Course Design:** By Alex Kontorovich alex.kontorovich@rutgers.edu\n"
"* **Interactive Implementation:** Lean 4 Game Engine\n"
"* **Mathematical Content:** Following Rudin, Stein-Shakarchi, Abbot, etc."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
msgid "# Problem 1"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "If `a n = 1 / n`, then `SeqLim a 0`; that is, the sequence\n"
"`1 / n` converges to zero."
msgstr ""

#: Game
msgid "An Introduction to (Formal) Real Analysis"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "The `apply` tactic solves a goal when one of the hypotheses is the same as the goal. The syntax is `apply hypothesis_name`"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Again, you presumably you know\n"
"now to do `intro n hn`. But let's also give `hn` the more descriptive name `n_ge_N`. So that I can keep giving you hints, try `intro n n_ge_N`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "# Theorem Prover Software\n"
"\n"
"In this course, we will be using a \"proof assistant\" called Lean. This is software that checks that our proofs prove *exactly* what we\n"
"claim they prove. It has other really cool pedagogical features that we'll get to later.\n"
"It will take a little while to get used to the syntax, so until we're comfortable, we'll intersperse exercises teaching Lean with exercises teaching Real Analysis. Pretty soon all the exercises will just be about Real Analysis.\n"
"\n"
"\n"
"For this first exercise, we have a hypothesis that we called `h` (but we could've called it anything, like `x_eq_5`, or `Alice`) that says a real number `x` equals 5. Our goal is to prove that `x` equals 5.\n"
"This shouldn't be very hard, but if you don't know\n"
"the command, you'll be out of luck. Our goal is to\n"
"prove the same statement as one of the hypotheses.\n"
"To solve that goal, the syntax is to write `apply`, then a space, and then the name of the hypothesis which matches the goal."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
#: Game.Levels.L2Pset.L2Pset2
#: Game.Levels.L3Pset.L3Pset2
msgid "Problem 2"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "# Extracting information from existential quantifiers\n"
"\n"
"Now let's learn the counterpart to `use`. You know that if you have `âˆƒ` in the goal, you write `use` to provide a specific value.\n"
"\n"
"But suppose you have a *hypothesis* that says \"there exists a real number `c` such that `f (c) = 2`\". In Lean, this looks like:\n"
"`h : âˆƒ (c : â„), f c = 2`\n"
"\n"
"And say you want to prove that \"there exists a real number `c` such that `(f c)^2 = 4`\".\n"
"\n"
"Again, you can't just say `apply h` because these are different statements.\n"
"If you know from `h` that at least one such `c` exists, how do you *choose* one?\n"
" The name of this command is... `choose`.\n"
"\n"
"The syntax for `choose` is as follows:\n"
"\n"
"`choose c hc using h`.\n"
"\n"
"You need to give a name to both the value of `c`, and to the hypothesis with which `c` is bundled. Here we named it `hc` (a hypothesis about `c`).\n"
"\n"
"You should be able to figure out how to solve the goal from here."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Prove that the sequence `a(n) = 1 / n` converges to 0.\n"
"This is our first substantive limit proof, requiring the Archimedean Property."
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
msgid "Solve the problem"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "# Problem Set 1\n"
"\n"
"Just because it's a problem set doesn't mean\n"
"you can't learn new things..."
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "# Problem 5\n"
"\n"
"You've learned about adding hypotheses with `have`, and that you can call tactics not\n"
"just to act on the Goal, but  also on hypotheses, via adding `at HypothesisName` at the end.\n"
"You also know that calling the `rewrite` tactic with a hypothesis `h : X = Y` takes the *left hand side* `X` and replaces it by `Y`. But what if you needed instead to replace `Y`'s by `X`'s? We call that \"backwards rewriting\". The syntax for that is:\n"
"\n"
"`rewrite [â† h]`\n"
"\n"
"or\n"
"\n"
"`rewrite [â† h] at h2`\n"
"\n"
"to do it at some other hypothesis, `h2`. You get the backwards arrow by typing \\left,\n"
"that is, the backslash, then the word `left`, and then a space.\n"
"\n"
"You may (or may not) find that useful in this problem."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For any sequence `a : â„• â†’ â„` and constant `L : â„`, and\n"
"hypothesis `h : âˆ€ n, a n = L`, the theorem `ConstLim`\n"
"proves that `SeqLim a L`, that is, the (constant) sequence `a` converges to `L`."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "# Problem 2\n"
"\n"
"In this problem you are asked to show that there is some `c` so that `(x + y) ^ 2 = c`, given that\n"
"`x * y = 1` and `x ^ 2 + y ^ 2 = 2`.\n"
"\n"
"You will likely have a hard time solving this problem as is.\n"
"You surely can work out what value of\n"
"`c` you need. But if you try\n"
"`ring_nf`, you won't have control over\n"
"how the \"normal form\" chooses to\n"
"express things. In fact, the\n"
"left-hand side, `(x + y) ^ 2` will\n"
"turn into `x * y * 2 + x ^ 2 + y ^ 2`,\n"
"which is parsed in this order:\n"
"\n"
"`(((x * y) * 2) + x ^ 2) + y ^ 2`\n"
"\n"
"This means that you *will* be able to\n"
"`rewrite [h2]` successfully,\n"
"but then you will *not* be able to rewrite by `h1`, because the (invisible) parentheses  go the wrong way. (Hint: If you want to know how things are grouped but don't see parentheses, you can hover your cursor over the text in the Goal State, and Lean will show you the groupings. Try it!)\n"
"\n"
"Now, in natural language, there are times when you might want to\n"
"record an auxiliary fact: \"let's\n"
"*have* the fact that such and such ...\". The Lean\n"
"syntax for this is as follows:\n"
"\n"
"`have NewFactName (Assumptions) : Conclusion := by Proof`\n"
"\n"
"That is, you first write `have`; then give\n"
"the new hypothesis a name; then include any\n"
"assumptions, like `(x : â„)`, meaning, `x`\n"
"is a real number, etc (the symbol `â„` is written with a backslash, then capital `R`, then space); then you put a colon,\n"
"and then state the conclusion; then you\n"
"put a colon-equals and the word `by`; and finally you give the proof.\n"
"\n"
"For example, if you wanted to declare\n"
"the new fact that, say, for any real `u` and `v`,\n"
"\n"
"`(u + v) ^ 2 = (u ^ 2 + v ^ 2) + 2 * (u * v)`\n"
"\n"
"and you wanted to call this fact `huv` (a hypothesis on `u` and `v`),\n"
"and you wanted to prove this fact by\n"
"invoking the ring normal form tactic,\n"
" then you would give Lean the command:\n"
"\n"
"`have huv (u v : â„), (u ^ 2 + v ^ 2) + 2 * (u * v) := by ring_nf`\n"
"\n"
"This will add to your list of hypotheses\n"
"the fact: `huv : âˆ€ (u v : â„), (u ^ 2 + v ^ 2) + 2 * (u * v)`.\n"
"\n"
"Something like this (if not exactly this)\n"
"will be useful to you in solving this problem."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The binomial expansion: $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$."
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "Pset 2"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Combine everything with `linarith [eps_inv_lt_N, f4]`"
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L3Pset.L3Pset4
msgid "Problem 4"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Prove that the sequence `1`, `-1`, `1`, `-1`,... diverges."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "While you may see `0 < Îµ` in the goal and `Îµ > 0` in the hypothesis `hÎµ`, Lean will still know that these two things are exactly the same..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "# A First Course in Real Analysis\n"
"\n"
"You may want to pull the left-most slider all the way to the right; what follows is a discussion\n"
"between \"Socrates\" and \"Simplicio,\" which hopefully  explains what it is we're trying to do here.\n"
"\n"
"**SIMPLICIO:** What is \"Real Analysis\"?\n"
"\n"
"**SOCRATES:** Oh, it's just Calculus, but done \"right\".\n"
"\n"
"**SIMPLICIO:** Huh? Why does Calculus need a new name? What's wrong with it?\n"
"\n"
"**SOCRATES:** Well, nothing really. Quick: what's a derivative?\n"
"\n"
"**SIMPLICIO:** Easy! If I have a function $f : \\R \\to \\R$ and it's differentiable at $x$, then the\n"
"derivative is $f'(x) := \\lim_{h \\to 0}\\frac{f(x+h) - f(x)}{h}$. This represents the \"instantaneous\" slope\n"
"of the graph of the function $y=f(x)$ at the point $(x, f(x))$.\n"
"[![derivative](images/Deriv.jpg)](https://en.wikipedia.org/wiki/Derivative)\n"
"\n"
"**SOCRATES:** Very good! And tell me please, what is an integral?\n"
"\n"
"**SIMPLICIO:** That's easy, too! If you want to integrate our function $f$ along an\n"
"interval, $[a, b]$, say, you pretend that you have infinitely many, infinitely small rectangles, work out their\n"
"areas as base times height, and add them up:\n"
"$\\int_a^b f(x)dx := \\lim_{N\\to\\infty} \\sum_{j=1}^N \\frac{b-a}{N} f\\left(a + j\\frac{b-a}{N}\\right)$\n"
"[![integral](images/Integral.jpg)](https://en.wikipedia.org/wiki/Integral)\n"
"\n"
"**SOCRATES:** Great. And what are the two Fundamental Theorems of Calculus?\n"
"\n"
"**SIMPLICIO:** These too are easy! The first one says that if you make a new function by integrating $f$\n"
"up to a variable amount, $x$, that is, let\n"
" $F(x) := \\int_a^x f(t)dt$, then the derivative of the new function is just $F'(x) = f(x)$.\n"
"\n"
"**SOCRATES:** And the second?\n"
"\n"
"**SIMPLICIO:**\n"
"The second one says that, conversely, if $F$ is an antiderivative of $f$, that is, $F'(x)=f(x)$, then\n"
"it's easy to work out the area under the curve, because\n"
" $\\int_a^b f(x)dx = F(b) - F(a)$.\n"
"So differentiation and integration are inverse operations!\n"
"\n"
"**SOCRATES:** Perfect. Now, here's the problem. You used words like \"limit\", \"infinitely many\", \"infinitely small\", and so on. What do they *actually* mean?\n"
"\n"
"**SIMPLICIO:** Oh, you know, it's when something  happens \"eventually\". You just have to get used to\n"
"the feel of it.\n"
"\n"
"**SOCRATES:** Hmm yes, I see. I agree that that's an OK way to think of it, for a while at least, and one that suited Newton (who\n"
"was quite uncomfortable with such words), and Leibniz (who was more care-free here), the two 17th century inventors of\n"
"calculus (if you don't count people like the ancient Greeks Eudoxus and Archimedes, or the 14th century Indian Madhava... but this isn't a history lesson). Leibniz taught the Bernoulli\n"
"brothers (the world's \"first AP Calc students\"!), who taught, among others, the Marquis de l'Hopital, and the great Leonhard Euler (the first \"Calc native\"), who taught the rest of us. All was going quite well... and then came the 19th Century.\n"
"[![NewtonLeibnizEudoxusArchimedesMadhavaBernoulliEuler](images/People.jpg)](https://en.wikipedia.org/wiki/History_of_calculus)\n"
"\n"
"**SIMPLICIO:** Huh? What happened in the 19th Century?\n"
"\n"
"**SOCRATES:** Well you see, a guy named Augustin-Louis Cauchy came along (roughly in the 1810s), and started making a fuss that we weren't really doing things perfectly \"rigorously\".\n"
"He set out to reprove the theorems of calculus using precise definitions rather than hand-waving.\n"
"He was making great progress, including proving statements like: the limit of continuous functions is continuous.\n"
"[![Cauchy](images/Cauchy.jpg)](https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy)\n"
"\n"
"**SIMPLICIO:** Sure, that sounds perfectly reasonable. A limit is a continuous process, so you do that to\n"
"continuous functions, and of course in the end you should get something continuous, too.  No?\n"
"\n"
"\n"
"**SOCRATES:** Well, the problem is that around the same time, a guy named Joseph Fourier was going around claiming\n"
" that he could add up a bunch of sines and cosines, and get basically any function he wants, including, say, the discontinuous sawtooth!\n"
"\n"
"**SIMPLICIO:** What?!\n"
"\n"
"**SOCRATES:** Look for yourself: Here's a graph of $\\sum_{n=1}^{100}\\frac1n \\sin(nx)$. As you take 100\n"
"out to infinity, Fourier claims that this will get\n"
"closer and closer to a sawtooth function!\n"
"[![Fourier](images/Fourier.jpg)](https://en.wikipedia.org/wiki/Joseph_Fourier)\n"
"\n"
"**SIMPLICIO:** Whoa. Wait, I can think of an even easier example: just look at the simplest family of\n"
"polynomials, $f_n(x) = x^n$, on the unit interval $[0,1]$. When you take high powers of any point\n"
"strictly less than $1$, that goes to $0$ in the limit, but powers of $1$ itself always stay at $1$.\n"
"So the limiting function is discontinuous, too! What the heck is going on here?\n"
"![Power Functions](images/Powers.png)\n"
"\n"
"\n"
"**SOCRATES:** Very good, Simplicio! Exactly right, between Fourier and Cauchy, they \"broke math\".\n"
" You break it, you buy it!\n"
"\n"
"**SIMPLICIO:** Ok, so what's the right answer, how *do* you do calculus rigorously?\n"
"\n"
"**SOCRATES:** Not so fast! Things got even worse, and by the mid-19th century, people realized that\n"
"we don't even know what the real numbers *are*!\n"
"\n"
"**SIMPLICIO:** What? What do you mean, what are they? Here they are right here: There's zero, and one, and $-2$, and $\\frac35$, and\n"
"$\\sqrt 2$, and $e$ and $\\pi$. What's the problem?\n"
"[![RealNumbers](images/RealLine.png)](https://en.wikipedia.org/wiki/Real_number)\n"
"\n"
"**SOCRATES:** Well, do you remember that you need something called the Intermediate Value Theorem\n"
"in calculus?\n"
"\n"
"**SIMPLICIO:** Sure, if you have a continuous function, and it goes from being negative to being positive,\n"
"then it has to cross zero at some point in between.\n"
"\n"
"**SOCRATES:** Very good. Tell me about the function $f : x \\mapsto x^2 - 2$. (We say: \"$f$ maps\n"
"$x$ to $x^2-2$\". Note that we write $f : \\R \\to \\R$ to mean that $f$ takes real numbers to real numbers, but\n"
"replace $\\to$ with $\\mapsto$ (see the tail on the second arrow?) when we want to say what happens to a particular input $x$ under the action of\n"
"$f$. Let me remind you that $x$ here is a dummy variable, so it's the same function if we'd said $f : u \\mapsto u ^ 2 - 2$.) In particular, what happens to $f$ on the rational numbers?\n"
"\n"
"**SIMPLICIO:** Ok, well if $x$ is a rational number, then so is $x^2$, and hence so is $x^2-2$.\n"
"So actually, we could say that $f : \\mathbb Q \\to \\mathbb Q$, that is, $f$ maps rational numbers to rational numbers.\n"
"Over the reals, the graph of $y=f(x)$ is a simple parabola.\n"
"But you'd asked me about the Intermediate Value Theorem. Hmm. When $x=0$, I know that $f(x)$ will\n"
"be $f(0)=0^2-2=-2$ which is negative. And when $x=2$, $f(2)=2^2-2=2$ which is positive.\n"
"\n"
"**SOCRATES:** Go on...\n"
"\n"
"**SIMPLICIO:** So there's a root of $f$ somewhere between $0$ and $2$. But the place where $f$ crosses the $x$-axis is at $x=\\sqrt2\\approx 1.41\\dots$.\n"
"\n"
"**SOCRATES:** And what did the Pythagoreans know about this number?\n"
"\n"
"**SIMPLICIO:** Supposedly one of them, Hippasus, figured out that $\\sqrt2$ is irrational, which ruined\n"
"their entire theory of geometry and form (they originally believed that *all* numbers were rational); legend has it\n"
"that Hippasus was drowned at sea for his herecy.\n"
"\n"
"**SOCRATES:** So...\n"
"\n"
"**SIMPLICIO:** So wait, if we just restrict to rational inputs, then this parabola is negative, and then\n"
"it's positive, and it *never* crosses zero?! But there's tons of rational numbers almost everywhere you look. So what makes the real numbers different from the\n"
"rational numbers, so that the Intermediate Value Theorem actually holds?\n"
"\n"
"**SOCRATES:** Ah! Now, my friend, we are ready to begin."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Also clear denominators in our key inequality: `field_simp at eps_inv_lt_N`"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "# Level 2: Our First Real Limit\n"
"\n"
"*Congratulations!* You've just proved the Archimedean Property. Now let's use it to prove something genuinely interesting: our first non-trivial limit.\n"
"\n"
"## The Goal: Proving that `1 / n â†’ 0`\n"
"\n"
"We want to prove that the sequence `a(n) = 1 / n` converges to `0` as `n` approaches infinity. This is intuitively obviousâ€”as `n` gets larger, `1 / n` gets smaller and approaches `0`. But how do we make this rigorous using the `Îµ`-`N` definition of limits?\n"
"\n"
"**Theorem**: The sequence `a(n) = 1 / n` converges to `0`.\n"
"\n"
"This might seem straightforward, but let's see it as a test of the definition.\n"
"\n"
"## Recall: The Definition of Sequential Convergence\n"
"\n"
"A sequence `a : â„• â†’ â„` converges to a limit `L` (written `SeqLim a L`) if:\n"
"\n"
"**For every `Îµ > 0`, there exists `N : â„•` such that for all `n â‰¥ N`, `|a(n) - L| < Îµ`**\n"
"\n"
"In formal notation: `âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, |a(n) - L| < Îµ`\n"
"\n"
"For our specific case with `a(n) = 1 / n` and `L = 0`, this becomes:\n"
"`âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, |1 / n - 0| < Îµ`\n"
"\n"
"## The Natural Language Proof Strategy\n"
"\n"
"Here's how we'll prove this step by step:\n"
"\n"
"**Step 1**: Let `Îµ > 0` be given. (This will correspond to `intro Îµ hÎµ`)\n"
"\n"
"**Step 2**: We need to find `N` such that for all `n â‰¥ N`, we have `1 / n < Îµ`.\n"
"\n"
"**Key insight**: We need `1 / n < Îµ`, which is equivalent to `1 / Îµ < n` (since both sides are positive). So we need `n` to be larger than `1 / Îµ`.\n"
"When our Engineer requests the tolerance of `Îµ = 1/100`, the Machinist replies, ok, I can do that, but I'll need `N = 1 / Îµ = 100` days in my factory.\n"
"\n"
"\n"
"**Step 3**: That's exactly why we developed the Archimedean Property! It tells us that there exists some natural number `N` such that `1 / Îµ < N`.\n"
"Rather than reproving that from scratch, we can simply quote this fact;\n"
"then\n"
"we'll choose such an `N` and use it.\n"
"\n"
"**Step 4**: Now let `n â‰¥ N` be given. We have:\n"
"- `1 / Îµ < N` (by our choice of `N`)\n"
"- `N â‰¤ n` (by assumption)\n"
"- Therefore: `1 / Îµ < N â‰¤ n`, so `1 / Îµ < n`\n"
"- Taking reciprocals (and flipping the inequality): `1 / n < Îµ`\n"
"\n"
"**Step 5**: Since `|1 / n - 0| = |1 / n| = 1 / n < Îµ`, we're done! â–¡\n"
"\n"
"## The Lean Implementation Challenges\n"
"\n"
"### Challenge 1: Cross-Multiplying Fractions\n"
"Our key step is showing that `1 / n < Îµ`. In paper mathematics, we'd simply cross-multiply to get `1 < n * Îµ`. But Lean is very careful about division by zero, so we can't just cross-multiply willy-nilly.\n"
"\n"
"**The Problem**: We want to go from `1 / n < Îµ` to `1 < n * Îµ`, but this is only valid if `n > 0` and `Îµ > 0`.\n"
"\n"
"**Solution**: The `field_simp` tactic handles this automatically! It will clear denominators by cross-multiplying, but only after it can verify that all denominators are positive (or at least non-zero).\n"
"\n"
"### Challenge 2: Linear Arithmetic\n"
"Once we've cleared the fractions, we need to combine various inequalities like:\n"
"- `1 / Îµ < N` (from the Archimedean Property)\n"
"- `N â‰¤ n` (our assumption)\n"
"- `1 < n * Îµ` (our goal after clearing denominators)\n"
"\n"
"For some reason, the `bound` tactic doesn't always handle these linear combinations well, especially when they involve multiplication by variables.\n"
"\n"
"**Solution**: The `linarith` tactic is specifically designed for linear arithmetic. It can take a list of hypotheses and solve goals that follow from linear combinations of those hypotheses.\n"
"\n"
"### Challenge 3: Explicit Type Casting\n"
"Remember those mysterious up arrows `â†‘` from the last level? They're back! When we write `1 / n`, Lean sees this as `1 / â†‘n` where `n` starts as a natural number but needs to be cast as a real number.\n"
"\n"
"Sometimes we have to be specific about what type of casting to use. The expression `1 / â†‘n` could be ambiguousâ€”are we casting to integers, rationals, reals, or something else?\n"
"\n"
"**Solution**: Instead of an up arrow, we can specify the casting explicitly with this syntax: `(n : â„)`. This tells Lean exactly what type we want to cast `n` to, in this case, the reals. This eliminates ambiguity and makes your proofs more precise.\n"
"\n"
"### Challenge 4: Casting in Tactic Applications\n"
"Sometimes you want to apply a tactic or theorem, but the types don't quite match because of casting issues. For example, you might have the hypothesis that `N â‰¤ n` where `n, N` are naturals, but `bound` or `linarith` are searching for a proof that `(N : â„) â‰¤ (n : â„)` as reals.\n"
"\n"
"**Solution**: The `exact_mod_cast` tactic is like `apply`, but it automatically handles the type coercions for you. If you're trying to prove `(N : â„) â‰¤ (n : â„)`, and you have the hypothesis `h : N â‰¤ n` (as naturals), then you can write: `exact_mod_cast h`. Lean will look at `h`\n"
"and realize, oh it's exactly what you're trying to prove, but just\n"
"cast to a different number system; and it'll figure out the proof from there.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- **`field_simp`**: Clears denominators by cross-multiplying, but only when it can prove the denominators are non-zero. This is the key to handling fractional inequalities safely.\n"
"\n"
"- **Arithmetic with inequalities**: You might also find the `linarith` tactic helpful. It is a very powerful, general tactic like `ring_nf`, but instead of proving algebraic *identities*, it proves *inequalities* involving \"linear arithmetic\" on the specified hypotheses. For example,\n"
"if you have as hypotheses: `hâ‚ : X â‰¤ Y`, `hâ‚‚ : 2 * Y â‰¤ Z`,\n"
"and your Goal is to prove that `2 * X â‰¤ Z`, then\n"
"simply calling `linarith [hâ‚, hâ‚‚]` will do the trick. So add as many inequality hypotheses to your Game Board as you may need, and then call `linarith` on them to prove a Goal. I find that `linarith` is best called at the very end, when you've assembled all your facts and are ready to close a Goal (but it has many other uses as well, as you'll see).\n"
"\n"
"- **Explicit casting `(n : â„)`**: Tells Lean exactly what type to use, eliminating ambiguity in expressions like `1 / n`. You only need to cast\n"
"once in any expression, and Lean will automatically cast everything else.\n"
"For example, you can say `(0 : â„) < N`, and Lean will figure out that\n"
"the `0` you mean is a real number, and so, to compare that with `N`,\n"
"the latter too must be cast to the reals.\n"
"\n"
"- **`exact_mod_cast`**: Automatically handles type coercions between different number types (â„•, â„¤, â„š, â„), when the Goal is *exactly*\n"
"what you're trying to prove, just needs to get coerced.\n"
"\n"
"\n"
"## Pro Tips for This Level\n"
"\n"
"1. **Use `change`** to convert `SeqLim a 0` to its definition\n"
"2. **Apply the Archimedean Property** to get the existence of an `N`\n"
"3. **Use `choose`** to extract the `N` from the existential statement\n"
"4. **Establish positivity first** before using `field_simp`\n"
"5. **Work step by step** - don't try to do everything at once!\n"
"\n"
"## What Makes This Non-Trivial?\n"
"\n"
"Unlike the constant sequence (which was essentially definitional), this proof requires:\n"
"- **The Archimedean Property** to find a suitable `N`\n"
"- **Careful type management** between `â„•` and `â„`\n"
"- **Positivity arguments** to handle division\n"
"- **Inequality manipulation** to connect our bounds\n"
"\n"
"This is a perfect example of how even \"obvious\" mathematical facts require sophisticated machinery to prove rigorously!"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Therefore `n > 0`; try: `have npos : (0 : â„) < n := by linarith [Npos, N_le_n]`"
msgstr ""

#: Game.Levels.L3Pset.L3Pset1
msgid "# Problem 1\n"
"\n"
"The \"full\" Archimedean Property is this:\n"
"Take two positive real numbers `x` and `y`. No matter\n"
"how large `y` may be, and how small `x` may be,\n"
"if we add `x` to itself enough times (that is, multiply it by some natural number), we can always get that to exceed `y`."
msgstr ""

#: Game.Levels.L3Pset.L3Pset4
msgid "Usage: given hypothesis `h : 0 â‰¤ X`, you can prove: `have : |X| = X := by apply abs_of_nonneg h`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "# Universal statements\n"
"\n"
"In mathematics, we often need to prove statements that are true \"for all\" values of some variable. For example, we might want to prove: \"for all $\\varepsilon > 0$, we have $(\\varepsilon + 1)^2 = (\\varepsilon + 1)^2$.\"\n"
"(Of course the condition that `Îµ` be positive is mathematically superfluous, and is only here for pedagogical purposes.)\n"
"\n"
"If you're thinking that `rfl` will do the trick, that's a good idea, but it won't work, because the goal isn't (yet) an equality. So we need to do something else first.\n"
"\n"
"In Lean, as in mathematics, \"for all\" is written using `âˆ€`; this is called the *universal quantifier*, and is gotten by typing \\forall, that is, backslash, then `forall`, then a space. In Lean, this goal looks like so:\n"
"\n"
"`âˆ€ Îµ > 0, (Îµ + 1)^2 = (Îµ + 1)^2`.\n"
"\n"
"(Note that to write an epsilon in Lean, you just type \\\\e, that is, backslash, then `e`, then space.)\n"
"\n"
"To prove a \"for all\" statement, you need to show that it's true for an arbitrary element. In English, you would say: give me an arbitrary `Îµ`, and give me the fact that it's positive (we can give that fact a name, like `hÎµ`, since it's a hypothesis about `Îµ`, or perhaps an even more descriptive name like `Îµ_pos`, since the hypothesis is the positivity of `Îµ`). Note that `Îµ` here is a dummy variable, and we could choose to name it something else on the fly. In English, we might say: give me some `Îµ`, but I want to call it `Alice`; then give me the fact that `Alice` is positive, and my goal will be to prove that `(Alice + 1)^2 = (Alice + 1)^2`. If we were more polite, we might replace \"give me\" above with \"introduce\", like:\n"
"introduce an `Îµ`, and introduce the fact, call it `hÎµ`, that `Îµ` is positive.\n"
"\n"
"In Lean, the syntax for this is the command `intro`, followed by whatever name you want to give a dummy variable or a hypothesis.\n"
"\n"
"So: when you see a goal that starts with `âˆ€`, you can write `intro` to \"introduce\" the variable. For example:\n"
"- `intro Îµ` introduces the variable Îµ. But look at the goal state now! It changes to: `Îµ > 0 â†’ (Îµ + 1)^2 = (Îµ + 1)^2`. So we're not done introducing things.\n"
"- Then `intro hÎµ` introduces the hypothesis that `Îµ > 0` (and again, you can call the hypothesis whatever you want; try `intro Îµ_pos` instead).\n"
"\n"
"After using `intro` twice, the goal will become one that you\n"
"should know how to solve.\n"
"\n"
"If you want to be really slick, you can combine the two `intro` commands into\n"
"one: `intro Îµ hÎµ`. But don't feel obliged."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Start by converting to the definition of sequential convergence using `change`."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "First Real Limit"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
#: Game.Levels.L3Pset.L3Pset1
#: Game.Levels.L3Pset.L3Pset2
#: Game.Levels.L3Pset.L3Pset3
#: Game.Levels.L3Pset.L3Pset4
msgid "Done."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The Convergence of a Sequence"
msgstr ""

#: Game.Levels.L3Lecture
msgid "# More on sequences\n"
"\n"
"In Lecture 2, we learned the definition of a sequence `a : â„• â†’ â„` converging to a limit `L`: for any tolerance\n"
"`Îµ > 0`, there exists a time `N`, so that, for any point after that time, `n â‰¥ N`, we are within the tolerance, `|a n - L| < Îµ`.\n"
"\n"
"We also learned how to do something completely trivial with it, namely, show that the constant sequence converges, with that constant as its limit.\n"
"\n"
"Let's step it up a notch, shall we?"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ðŸŽ‰"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Cast the inequality `n â‰¥ N` to reals, so that `linarith` can see and access it: `have N_le_n : (N : â„) â‰¤ n := by exact_mod_cast n_ge_N`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Write `apply h` since the hypothesis `h` is  what we want to prove."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "NonConvergence"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "# Algebraic manipulations\n"
"\n"
"Now let's learn about algebraic simplification. Suppose you need to prove that $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$.\n"
"\n"
"This is true by the basic laws of algebra - expanding the left side using the distributive law, commutativity, associativity, etc. But doing this by hand would be extremely tedious.\n"
"\n"
"Fortunately, Lean has a powerful tactic called `ring_nf` (\"ring normal form\") that can automatically perform algebraic manipulations like:\n"
"- Expanding products\n"
"- Collecting like terms\n"
"- Rearranging using commutativity and associativity\n"
"- Applying the distributive law\n"
"\n"
"When you have an algebraic identity involving addition, subtraction, and multiplication, `ring_nf` can often prove it automatically.\n"
"\n"
"Try it out on this classic binomial expansion!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "This is where you might find it useful to call `norm_num` and normalize `|0|` to `0`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "If a function of `x` always equals `xÂ²`, then it equals `tÂ²` when evaluated at `t`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "For all positive real numbers, this algebraic identity holds."
msgstr ""

#: Game.Levels.L3Pset.L3Pset4
msgid "Determine the limit `L` of the sequence `a (n) = (3n + 8) / (2n + 5)`, and prove that `a` indeed converges to `L`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Every mathematical expression equals itself."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L3Pset.L3Pset1
msgid "Problem 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Write `use 42`, but with `42` replaced by the correct answer. Then how should you finish?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Type `rewrite [Bob]` to replace `x` with `2` in the goal. Then what?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The `ring_nf` tactic puts both sides of an equation into a standard algebraic form and checks if they're equal."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Use `intro Îµ` to introduce the variable, then `intro hÎµ` to introduce the hypothesis `Îµ > 0`. Then how do you solve the goal?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "Lecture 1: The Story of Real Analysis"
msgstr ""

#: Game.Levels.L3Pset.L3Pset3
msgid "# Problem 3\n"
"\n"
"Determine what the limit of the sequence `1 / n ^ 2` is, and prove it.\n"
"\n"
"Hints you may find useful:\n"
"- We have yet to learn about dealing with the square-root function.\n"
"So see if you can be even lazier in your choice of parameters...\n"
"- If you know that `h : 0 < N` holds in the *natural* numbers, then you can prove that that `1 â‰¤ N` simply by `apply`ing `h`, that is: `have h' : 1 â‰¤ N := by apply h`. (This would not work for an inequality in the real numbers, since it's in general not true!)"
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
msgid "Find the correct constant."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "# Rewriting with equalities\n"
"\n"
"Now let's learn about rewriting. Suppose you have a hypothesis called `Bob : x = 2`, and your goal is to prove that `x + y = 2 + y`.\n"
"\n"
"Can you use `rfl`? No, because the two sides of the goal (`x + y` and `2 + y`) are not *identically* the same.\n"
"\n"
"Can you use `apply Bob`? No, because `Bob` says `x = 2`, which is not what the goal is asking for.\n"
"\n"
"But you can use the hypothesis `Bob` to *rewrite* the goal. Since `Bob` tells us that `x = 2`, we can replace `x` with `2` in our goal.\n"
"\n"
"In Lean, if you have a hypothesis which is an equality, and you want to replace the *left hand side* of that equality with the *right hand side* in your goal, you use the `rewrite` tactic. The syntax is:\n"
"\n"
"`rewrite [hypothesis_name]`\n"
"\n"
"Unfortunately, those square brackets are part of the Lean syntax, and there's nothing you or I can do about them right now. Just remember: `rewrite [Bob]` means \"use the equality in `Bob` to rewrite the goal.\"\n"
"\n"
"After you rewrite, you're not done. But you should know how to finish from there.\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Great! You've learned the `rewrite` tactic.\n"
"\n"
"Notice what happened: after you typed `rewrite [Bob]`, the goal changed from `x + y = 2 + y` to `2 + y = 2 + y`. Then you needed to type `rfl` to finish the proof, since both sides were now identical.\n"
"\n"
"So far you've learned:\n"
"- `apply hypothesis_name` when a hypothesis matches your goal\n"
"- `rfl` when you need to prove something equals itself\n"
"- `rewrite [hypothesis_name]` when you want to use an equality to rewrite your goal\n"
"\n"
"The `rewrite` tactic is incredibly powerful and you'll use it constantly in real analysis!"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Simplify the absolute value: `have f2 : |1 / (n : â„)| = 1 / n := by bound`. Note the explicit casting to the reals, so that this is not a statement about natural numbers!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# ðŸŽ‰ Excellent Work! ðŸŽ‰\n"
"\n"
"You've just completed your first rigorous limit proof! Let's reflect on what you accomplished and the key insights from this foundational example.\n"
"\n"
"**What you just proved:**\n"
"You showed that if a sequence always outputs the same value `L`, then it converges to `L`. The Machinist's response to any tolerance demand `Îµ > 0` is beautifully simple: 'I can meet that specification immediately with any production run length `N`, because I'm already producing exactly what you want!'\n"
"\n"
"**Key Insights from this proof:**\n"
"\n"
"1. **The `change` tactic**: You learned how to unfold a definition to see what you're really trying to prove. `SeqLim a L` became the concrete epsilon-N condition.\n"
"\n"
"2. **The logical structure**: The proof followed the natural flow of the definition:\n"
"   - `intro Îµ hÎµ` handled 'for every Îµ > 0'\n"
"   - `use 1` provided the witness `N` (any number works!)\n"
"   - `intro n hn` handled 'âˆ€ n â‰¥ N'\n"
"   - Then algebraic manipulation showed that `|a n - L| = |L - L| = |0|`\n"
"   - Then numerical normalization gave that `|0| = 0`, and `hÎµ` finally proved that `|a n - L| < Îµ`.\n"
"\n"
"**The Beautiful Simplicity:**\n"
"This is the Machinist's dream scenarioâ€”no matter how demanding the engineer's tolerance requirements, the constant factory can satisfy them instantly. There's no trade-off between precision and effort because the output is already perfect!\n"
"\n"
"You're building the foundation for all of calculus. Every limit, derivative, and integral ultimately rests on arguments like this one.\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Let's step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If a sequence has the same value for every term, then it converges to that constant value.\n"
"\n"
"**Proof:** Suppose we have a sequence $a(n)$ where $a(n) = L$ for all $n$, and we want to show that this sequence converges to $L$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|a(n) - L| < \\varepsilon$.\n"
"\n"
"This is almost trivially simple: since $a(n) = L$ for every $n$, we have:\n"
"$$|a(n) - L| = |L - L| = |0| = 0$$\n"
"\n"
"Since $0 < \\varepsilon$ for any positive $\\varepsilon$, we can choose any $N$ we want (we chose $N = 1$ in the proof, but $N = 0$ or $N = 1000$ would work equally well).\n"
"\n"
"Therefore, for any $n \\geq N$, we have $|a(n) - L| = 0 < \\varepsilon$, which proves convergence.\n"
"**QED**"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The ring_nf tactic"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
msgid "Given that `f (u) = 2 * u + 1` for all `u`, prove that there exists some `a` such that `f (3) = a`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "# Proving existence\n"
"\n"
"Sometimes in mathematics, you need to prove that something exists. For example, suppose I wanted to ask you what the binomial coefficient in front of $x^2y^2$ is\n"
"in the expansion of $(x+y)^4$; how would I do it? Lean can't ask questions,\n"
"it can only prove theorems! So the way I would ask this is:\n"
"  prove that there exists a real number $c$ such that\n"
"\n"
"  $(x+y)^4 = x^4 + 4x^3y + cx^2y^2 + 4xy^3 + y^4$.\n"
"\n"
"  The way to prove that such a number\n"
"  exists is to exhibit it, that is, tell me which number to *use*,\n"
"  and then prove that that number indeed satisfies the equation.\n"
"\n"
"This is called an *existential statement*. In Lean, as in mathematics,\n"
"existence is written using `âˆƒ` (read: \"there exists\").\n"
"This symbol is called the *existential quantifier*, and is written in Lean by typing \\exists, that is, a backslash, then the word `exists`, and then a space.\n"
"So this goal would look in Lean like so:\n"
"\n"
"`âˆƒ (c : â„), (x + y)^4 = x^4 + 4*x^3*y + c*x^2*y^2 + 4*x*y^3 + y^4`\n"
"\n"
"To prove an existence statement, you need to provide a specific value that works. This is where the `use` tactic comes in.\n"
"\n"
"If you think you know what value of `c` would work, you can write `use 42` (or with `42` replaced by whatever number you think is right). Lean will then substitute that value and ask you to prove that the resulting equation is true.\n"
"\n"
"Try writing `use`, then a space, and then a number. Do you see what to do after that?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "If we know that $x = 2$, then we can prove that $x + y = 2 + y$."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "The `have` tactic has the following\n"
"syntax: `have NewHypothesisName (Assumptions) : Claim := by GiveTheProof`.\n"
"This creates a new hypothesis called\n"
"`NewHypothesisName : âˆ€ (Assumptions), ClaimHolds`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "# Using universal statements\n"
"\n"
"Now let's learn the flip side of `intro`. You have already learned that:\n"
"- if you have `âˆƒ` in the goal, you write `use` to provide a specific value. And\n"
"- if you have `âˆ€` in the goal, you write `intro` to introduce an arbitrary variable\n"
"\n"
"But what if you have `âˆ€` in a *hypothesis* and you want to use it for a particular value?\n"
"\n"
"For a concrete example, suppose you have:\n"
"- A positive real number `t`; that is, a real number `t`, together with a hypothesis, say, `t_pos` that `t > 0`\n"
"- A function `f : â„ â†’ â„`\n"
"- A hypothesis `hf : âˆ€ x > 0, f (x) = x^2`, meaning \"for all x positive, f (x) equals xÂ²\". (Note that you *have* to put a space after `f` before `(x)` or else Lean will be very angry with you! In fact, Lean will often drop unnecessary parentheses, so you'll see `f x` instead of `f (x)` -- and again, definitely *not* `f(x)`.)\n"
"- And you want to prove the goal `f (t) = t^2`.\n"
"\n"
"Can you use `apply hf`? No! The hypothesis `hf` says \"for all positive x, f (x) = xÂ²\" but the goal asks specifically about `f (t) = tÂ²`. They're not  the same.\n"
"\n"
"This is where the `specialize` command comes in. You can write `specialize hf t` to specialize the statement `hf` to the particular value `t`. This transforms `hf` from \"âˆ€ x > 0, f (x) = xÂ²\" into \"t > 0 â†’ f (t) = tÂ²\". Just like we had to `intro` multiple times (once for the dummy variable name, and again to name the hypothesis), we can specialize multiple times; so you can now write `specialize hf t_pos`. Or you can kill two birds with one stone via: `specialize hf t t_pos`.\n"
"\n"
"I'm sure you can solve the goal from there yourself!"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Usage: `have factName : |x + y| â‰¤ |x| + |y| := by apply abs_add`"
msgstr ""

#: Game.Levels.L2Pset.L2Pset2
msgid "# Problem 2\n"
"\n"
"Do the same for the exponent $3/2$. Find constants `c`, `d`, and `e` so that:\n"
"\n"
"$(1 + \\frac32 x + c \\cdot x^2 + d \\cdot x^3 + e \\cdot x^4)^2 - (1 + x) ^ 3$\n"
"\n"
"has only terms of degree five or higher.\n"
"\n"
"Hint: when you have multiple existential quantifiers, you can just write a single `use`\n"
"and separate the answers by a comma, like so: `use 6, 7, 42` (in place of: `use 6`, then `use 7`, then `use 42`)."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Step 3:\n"
"Once more, in natural language.\n"
"\n"
"\n"
"## Natural Language Proof\n"
"\n"
"**Theorem:** The sequence `1`, `-1`, `1`, `-1`, ... does not converge.\n"
"\n"
"**Proof by contradiction:**\n"
"1. Suppose the sequence converges to some limit `L`\n"
"2. Set `Îµ = 1 / 2` and apply the convergence definition\n"
"3. This guarantees some `N` such that `|a n - L| < 1 / 2` for all `n â‰¥ N`\n"
"4. Consider two specific indices: `n = 2N` and `n = 2N+1` (both are `â‰¥ N`)\n"
"   - `a (2N) = (-1)Â²á´º = 1`, so `|1 - L| < 1 / 2`\n"
"   - `a (2N+1) = (-1)Â²á´ºâºÂ¹ = -1`, so `|-1 - L| < 1 / 2`.\n"
"5. But then:\n"
"   `2 = |1 - (-1)| = |(1 - L) + (L + 1)|`\n"
"     `â‰¤ |1 - L| + |L + 1|`     [triangle inequality]\n"
"     `= |1 - L| + |-1 - L|`    [algebraic manipulation]\n"
"     `< 1/2 + 1/2 = 1`         [from steps above]\n"
"6. This gives us `2 < 1`, which is impossible. QED\n"
"\n"
"## Key Insights\n"
"\n"
"- **Geometric intuition:** Any proposed limit L must be within 1/2 of both 1 and -1 simultaneously, but these values are distance 2 apart\n"
"- **Critical Îµ choice:** We chose Îµ = 1/2 strategically; larger values like Îµ = 1.5 wouldn't work since L = 0 could satisfy the constraints.\n"
"- **Triangle inequality:** The key step uses |a + b| â‰¤ |a| + |b| to convert the distance between sequence values into a sum of distances from the limit.\n"
"\n"
"This proof exemplifies how rigorous definitions resolve historical mathematical debates and provide clear criteria for convergence."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "# Level 1: The Archimedean Property\n"
"\n"
"The so-called Archimedean Property (which I think is originally due to Eudoxus, and appears already in Euclid's Elements Book V) is a fundamental property of the real numbers that captures the intuitive notion that there are no \"infinitely large\" or \"infinitesimally small\" positive real numbers.\n"
"\n"
"More precisely, it states that no matter how small `Îµ > 0` is, there is always a natural number `N` so that `1 / N` is even smaller than `Îµ` (and of course positive). Equivalently, we can state it as: for any positive real number `Îµ`, there exists a natural number `N` such that `1 / Îµ < N`.\n"
"\n"
"*Why does this matter?* The Archimedean Property is one of the most fundamental properties distinguishing the real numbers from other number systems. Without it, we could have \"infinitely large\" or \"infinitesimally small\" positive numbers, which would break most of calculus and analysis.\n"
"\n"
"Our goal will be to prove the following:\n"
"\n"
"**Theorem (ArchProp)**: For any `Îµ : â„` with `0 < Îµ`, there exists `N : â„•` such that `1 / Îµ < N`.\n"
"\n"
"This is mathematically \"obvious\" to most peopleâ€”if you have a positive number Îµ, no matter how small, you can always find a natural number large enough that 1 / Îµ is smaller than it. But how do you actually formalize this in Lean?\n"
"\n"
"## The Natural Language Proof Strategy\n"
"\n"
"First, let's think about this in natural language. The key insight is that we need to provide a specific natural number `N` that works.\n"
"\n"
"A natural choice would be to use something related to the ceiling function. The ceiling function `x â†¦ âŒˆxâŒ‰` rounds any real number up to the nearest integer. However, there's a subtle issue here: the standard ceiling function takes values in integers `â„¤`, but we need values in `â„•` (the natural numbers). These are *not* the same thing!!\n"
"\n"
"Fortunately, Lean provides the \"natural number ceiling function\" written `x â†¦ âŒˆxâŒ‰â‚Š`, which takes any real number and returns a natural number.\n"
"(You can write these symbols using `\\lceil`, `\\rceil`, and `\\_+`. Or if you're lazy like me, just copy and paste them from elsewhere.)\n"
" For negative inputs, this function returns `0`. For example, `âŒˆ-3.14âŒ‰â‚Š = 0` and `âŒˆ3.14âŒ‰â‚Š = 4`.\n"
"\n"
"Now our strategy becomes clear:\n"
"- **Choice of N**: Use `N = âŒˆ1 / ÎµâŒ‰â‚Š + 1`\n"
"- **Why this works**: We have the \"key inequality\": `1 / Îµ â‰¤ âŒˆ1 / ÎµâŒ‰â‚Š`, which holds by the definition of the ceiling function\n"
"- **Getting strict inequality**: Adding 1 gives us `1 / Îµ < âŒˆ1 / ÎµâŒ‰â‚Š + 1`\n"
"\n"
"## The Lean Implementation Challenges\n"
"\n"
"In Lean, the first two steps of our natural language proof work fine, but then we encounter the issue of **type coercion** (\"casting\" between different number types). We'll discuss this in more detail later, but again it has to do with the fact that `â„•`, `â„¤`, `â„š`, and `â„` are all different kinds of things, and we need to be able to move numbers up the \"sophistication\" heirarchy, with natural numbers being the simplest objects and the reals being the most complicated (so much so that we keep postponing their construction).\n"
"\n"
"For example, notice that when we'll write our `have` statement to establish the key inequality:\n"
"\n"
"`have fact : 1 / Îµ â‰¤ âŒˆ1 / ÎµâŒ‰â‚Š := by WhateverTheProofIs`\n"
"\n"
"Lean will record it as:\n"
"\n"
"`fact : 1 / Îµ â‰¤ â†‘âŒˆ1 / ÎµâŒ‰â‚Š`\n"
"\n"
"Notice the mysterious up arrow `â†‘`. This represents a coercion function from natural numbers to real numbers:\n"
"\n"
"â†‘ : â„• â†’ â„\n"
"\n"
"This is because `â„•`, `â„¤`, `â„š`, and `â„` are all **different** types in Lean's type system (and really, in mathematics, as we'll see when we construct the real numbers)! Even though we think of natural numbers as being \"contained\" in the real numbers, formally they are distinct types of things, and Lean needs explicit coercion functions to convert between them.\n"
"\n"
"*Think of it this way*: the natural number `3 : â„•` and the fraction `3 / 1 : â„š` and the real number `3.000 : â„` are different objects that just happen to represent the same mathematical value.\n"
"\n"
"The `push_cast` tactic helps manage these coercions, kind of like `ring_nf` but for casting instead of ring operations.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- `âŒˆ â¬ âŒ‰â‚Š`: The natural number ceiling function\n"
"- `push_cast`: Tactic that handles coercions between number types\n"
"- `bound`: Solves many routine inequalities\n"
"\n"
"The `bound` tactic can solve many \"trivial\" inequalities once the types are properly aligned.\n"
"\n"
"## Hint:\n"
"\n"
"If you get stuck and don't see a Hint, try backtracking until you do."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Excellent! You've learned the `rfl` tactic.\n"
"\n"
"The key difference:\n"
"- Use `apply hypothesis_name` when you have a hypothesis that matches your goal\n"
"- Use `rfl` when you need to prove that something equals itself\n"
"\n"
"These are two of the most fundamental tactics in Lean. As we progress through real analysis, you'll see that many complex proofs ultimately come down to showing that two expressions are identical."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Usage: `have factName : |-x| = |x| := by apply abs_neg`"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "A sequence `a : N â†’ â„` converges (`SeqConv a` holds) if there exists some\n"
"`L : â„` so that `a â†’ L`, that is, `SeqLim a L` holds."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "The `bound` tactic can solve many \\\"trivial\\\" inequalities involving standard functions and basic arithmetic."
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "Problem 5"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Perfect! You've learned the `use` tactic for existence proofs.\n"
"\n"
"Notice what happened:\n"
"1. `use 6` told Lean that $c = 6$ is our proposed value\n"
"2. The goal changed to proving $(x + y)^4 = x^4 + 4x^3y + 6x^2y^2 + 4xy^3 + y^4$\n"
"3. `ring_nf` verified that this algebraic identity is correct\n"
"\n"
"The `use` tactic is fundamental in real analysis. You'll need it to:\n"
"- Find specific values of $\\varepsilon$ and $\\delta$ in limit proofs\n"
"- Construct witnesses for existence theorems\n"
"- Provide counterexamples\n"
"\n"
"Your growing toolkit:\n"
"- `apply`, `rfl`, `rewrite` for basic equality reasoning\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for existence proofs"
msgstr ""
