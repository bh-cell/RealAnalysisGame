msgid ""
msgstr "Project-Id-Version: Game v4.23.0-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-07\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.L1Pset.L1Pset2
msgid "Did you end up using `huv`?\n"
"And then `specialize`ing it with `u` and `v` replaced, respectively, by `x` and `y`?\n"
"Or did you think of going via the more direct route:\n"
"`have hxy : (x + y) ^ 2 = (x ^ 2 + y ^ 2) + 2 * (x * y) := by ring_nf`?"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ðŸŽ‰"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The `use` tactic provides a specific value to prove an existence statement."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Write `specialize hf t` to apply the universal statement to the specific value t."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "If you're stuck at this point, let me remind you that, in a previous level, the Goal was: `âˆ€ Îµ > 0, BlahBlah`, and\n"
"after `intro Îµ`, the Goal became `Îµ > 0 â†’ BlahBlah`.\n"
"Then what did you do?..."
msgstr ""

#: Game
msgid "Learn real analysis through the historical crises that forced mathematicians to rebuild calculus from the ground up in the 19th century."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "Write `choose c hc using h`, then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "Big Boss: The Ultimate Tactic Challenge"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# ðŸŽ‰ VICTORY! ðŸŽ‰\n"
"\n"
"You've defeated the Big Boss and mastered all the fundamental tactics of mathematical reasoning!\n"
"\n"
"**Let's see what you just accomplished:**\n"
"\n"
"1. **`choose a ha using h_existential`** - Extracted the witness `a` and fact that `f (a) = 3` from the hypothesis\n"
"2. **`use a`** - Chose `a` as your witness for the existence statement in the goal\n"
"3. **`intro y hy`** - Handled the universal quantifier \"for all y > 0\" in the goal\n"
"4. **`specialize h_universal y hy`** - Applied the universal property to your specific value in the hypothesis\n"
"5. **`rewrite [h_universal]`** - Used the specialized fact to rewrite the goal\n"
"6. **`rewrite [ha]`** - Used the original fact that `f (a) = 3` to also rewrite the goal\n"
"7. **`ring_nf`** - Verified finally that `(f y + 9) ^ 2 = (f y + 3 ^ 2) ^ 2`\n"
"\n"
"You've just completed a genuinely sophisticated mathematical argument! This kind of multi-step reasoning, combining existence statements, universal properties, and algebraic manipulation, is exactly what you'll encounter throughout real analysis.\n"
"\n"
"**You are now ready to begin your journey to rigorous calculus!**\n"
"\n"
"Welcome to the Introduction to Formal Real Analysis. ðŸŽ“\n"
"\n"
"**Epilogue**\n"
"\n"
"Before we continue with more Real Analysis and more Lean, letâ€™s pause to note a few interesting things about working formally.\n"
"Using a theorem prover interactively is (I hope) tremendously fun and (I hope) leads to rapid gains, immediate feedback, and clarity of thought.\n"
"\n"
"Imagine trying to learn chess by just reading through algebraic notation - 1.e4 e5 2.Nf3 Nf6 3.Bb5 a6 - sure, all the information is technically there, but isn't it so much easier to learn by actually looking at a chess board and seeing how the position changes after each move? In mathematics, it would be extraordinarily tedious to manually write on the blackboard the entire goal state after every move, keeping track of all the hypotheses and their relationships by hand. A theorem prover does this bookkeeping for you automatically, letting you focus on the mathematical content rather than the clerical work.\n"
"\n"
"But! This is, as we've already noted, a double-edged sword. We still want to train our brains to \"see\" a mental model of the goal state evolving - good chess players can visualize many moves ahead precisely because they've learned to maintain multiple mental game boards simultaneously. But until you develop that skill, and even after you have it, there's immense value in being able to instantly generate the current \"game board\" of your proof state. The immediate feedback helps you understand the consequences of each logical move, building the very intuition that will eventually let you work more independently. It's the difference between learning to navigate by always checking your GPS versus eventually developing an internal sense of direction - both have their place, and the former helps develop the latter."
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
msgid "# Problem 4\n"
"\n"
"This problem looks very similar to the previous one, but without a few hints, it\n"
"may cause great difficulty. The issue is that, last time, you likely called `specialize h1 0`, and turned `h1` into:\n"
"\n"
"`h1 : g (0 + 1) = g (0) + 3`\n"
"\n"
"If you do that now, the original `h1` will be *gone*, and you won't have a way of accessing it *again* to bootstrap from `g (1)` to `g (2)`. So what should you do?\n"
"\n"
"Observe that `have` can perform the same\n"
"role as `specialize` (and much more)! Try starting your solution with:\n"
"\n"
"`have h3 : g (0 + 1) = g (0) + 3 := by apply h1 0`\n"
"\n"
"This will not affect the original statement\n"
"of `h1`, but will instead add a *new* hypothesis, `h3`, which amounts to the\n"
"desired fact that `g (0 + 1) = g (0) + 3`.\n"
"Notice what's happening in the proof: `h1` says: for all `x`, `g (x + 1) = g (x) + 3`.\n"
"So `h1` is really a *function* whose input\n"
"is a real number `x`, and whose output is a\n"
"*proof* of the fact that, for this value of `x`, `g (x + 1) = g (x) + 3` holds. So when\n"
"we feed `0` into `h1`, it has the same effect\n"
"as it did when we `specialize`d, thus giving a proof of\n"
" exactly what was claimed in the `have` statement.\n"
"\n"
"Now you should be able to solve this problem."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The `rfl` tactic proves goals of the form `A = A` where both sides are *identical*."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ðŸŽ­"
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "# Problem Set 2\n"
"\n"
"This is problem set 2."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The intro tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Great! You've learned the `specialize` tactic.\n"
"\n"
"Notice what happened:\n"
"1. Initially, `hf : âˆ€ x > 0, f (x) = x^2` was a universal statement\n"
"2. `specialize hf t` transformed it into `hf : t > 0 â†’ f (t) = t ^ 2`\n"
"3. Another `specialize` command, namely `specialize hf t_pos` turned the\n"
"hypothesis `hf` into `hf : f (t) = t ^ 2`\n"
"4. And finally, `apply hf` worked because the hypothesis matched the goal.\n"
"\n"
"The pattern is:\n"
"- `intro` when you have `âˆ€` in the goal (\"introduce an arbitrary term...\")\n"
"- `specialize` when you have `âˆ€` in a hypothesis (\"apply the hypothesis to specific value...\")\n"
"\n"
"This is fundamental in real analysis when working with:\n"
"- Function properties that hold \"for all x\"\n"
"- Limit definitions involving \"for all Îµ > 0\"\n"
"- Continuity statements\n"
"\n"
"Last lesson in Lecture 1 coming up."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Excellent! You've learned the `intro` tactic for universal statements.\n"
"\n"
"Notice what happened:\n"
"1. `intro Îµ` introduced the arbitrary real number Îµ\n"
"2. `intro hÎµ` introduced the hypothesis `hÎµ : Îµ > 0`\n"
"3. The goal became `(Îµ + 1)^2 = (Îµ + 1)^2`\n"
"4. `rfl` solved the goal, by the reflexive property of the equals sign.\n"
"\n"
"You might have noticed something interesting: we used `intro` in two seemingly different ways -- first to introduce an \"Object\" (the real number `Îµ`), and second to introduce an \"Assumption\" or hypothesis (that `Îµ > 0`). In Lean's underlying logic (\"dependent type theory\"), there's actually a deep unity here that mathematicians call the *Curry-Howard correspondence*: propositions are \"Types\", and proofs are \"Terms\" of those Types. This means that introducing a hypothesis is really just introducing a term of a certain type, just like introducing a variable.\n"
"\n"
"But here's an even more mind-bending perspective: our entire Statement is really a *function*! Its inputs are first an `Îµ : â„`, then a proof that `Îµ > 0`, and its output is a proof that `(Îµ + 1)^2 = (Îµ + 1)^2`. When we write `intro Îµ` and `intro h`, we're literally defining this function by saying \"given these inputs, here's how to compute the output.\" In this view, all of mathematics -- from the simplest definitions to proofs of the deepest theorems -- is secretly just **functions** transforming inputs into outputs!\n"
"\n"
"This beautiful connection between logic and computation underlies much of modern proof assistants, though we won't dive into the details in this course -- it's perfectly fine if you didn't follow the last two paragraphs! For now, just appreciate that `intro` works uniformly whether you're introducing mathematical objects or logical assumptions, and that every proof you write is secretly a program!\n"
"\n"
"The `intro` tactic is absolutely crucial in real analysis. You'll use it constantly to:\n"
"- Handle \"for all Îµ > 0\" statements in limit definitions\n"
"- Introduce arbitrary points in domain/range proofs\n"
"- Work with function definitions\n"
"\n"
"This pattern of `intro` followed by algebraic manipulation is everywhere in analysis!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# Level 1: The Main Definition\n"
"\n"
"Our first step to making Newton's argument rigorous is\n"
"to spell out *exactly* what we mean by a sequence\n"
"$a_n$ converging. It will take a little work to build up to the definition, and more importantly, *why*\n"
"that might seem like a reasonable definition to have.\n"
"\n"
"But first: for some reason (likely Euler is to blame), mathematics has *two* completely different conventions for how to write functions. For general functions $f : \\mathbb R \\to\\mathbb R$,\n"
"we write $f(x)$, with parentheses. But when work with sequences, $a_n$, meaning,\n"
"$a_0, a_1, a_2, \\dots$, we bizarely switch instead to subscripts.\n"
"Why? Historical accident.\n"
"A sequence is nothing but a function whose \"domain\" (that is, the set of\n"
"inputs to the function) is the natural numbers; so we will break\n"
"with tradition and unify the two conventions, henceforth writing\n"
"$a : \\mathbb N \\to \\mathbb R$ for sequences of real numbers, $a (0), a (1),\n"
"a (2), \\dots$.\n"
"\n"
"Now, the definition that mathematicians eventually came up with\n"
"for what it means for a sequence to converge, was so intricate (at least\n"
"at first sight) that it had to be invented *twice*!\n"
"The eventual formulation crystallized through the work of Karl Weierstrass in the 1860s, who transformed analysis from an intuitive art into a rigorous science. However, the seeds of this idea appeared much earlier in the work of Bernard Bolzano. In the 1810s and 1820s, Bolzano was developing remarkably modern ideas about continuity and limits, but he was too far ahead of his time for the mathematical community to accept these abstract concepts.\n"
"Only by Weierstrass's time -- a half-century later -- did these ideas catch on.\n"
"\n"
"Without further ado, here it is:\n"
"\n"
"Given a sequence `a : â„• â†’ â„` and a real number `L : â„`, we\n"
"write `lim a = L` and\n"
"say that the sequence `a` **converges** to `L`,\n"
" if:\n"
"\n"
"For every `Îµ > 0`, there exists `N : â„•` such that, for all `n â‰¥ N`, we have `|a (n) - L| < Îµ`.\n"
"\n"
"\n"
"This definition is probably not the first, or second, or tenth thing you might've come up with.\n"
"But over time, I hope you'll come to see that it\n"
" embodies a beautiful negotiation between precision and effort.\n"
"\n"
" I like to think of it as a conversation between an Engineer and a Machinist. The Engineer arrives with specifications: 'We're going to make this widget, and I need its length to be 1 foot, with an error tolerance\n"
" of 1/100 of an inch'. The Machinist replies: 'Sure, I can do that, but I'll have to run my special equipment for at least 10 hours to guarantee that tolerance.' The Enginner\n"
" replies: 'I'm sorry, I misspoke, can we change the tolerance\n"
" to 1/1000 of an inch?' The Machinist replies: 'Oof, yeah we can do it, but it'll cost ya. I'll need at least 40 hours of operation, but after that, I'll guarantee it.'\n"
"\n"
"As long as this conversation can continue regardless of *whatever* tolerance `Îµ > 0` the Engineer requires, with the Machinist\n"
"always being able to reply with a finite minimum number of hours `N`,\n"
"after which the tolerance will be achieved, we can say\n"
"that the equipment **converges**.\n"
"\n"
"Now let's read Weierstrauss's (or is it Bolzano's?) definition again. We have some process\n"
"that at time `n` returns a reading `a (n)` (think: widget length). Our ultimate goal is to make the length `L`. If\n"
"for any tolerance `Îµ > 0`, no matter how small, there will always exist some minimum\n"
"time `N`, so that, for any future time, `n â‰¥ N`,\n"
"we are guaranteed to be within that tolerance, `|a (n) - L| < Îµ`, that's exactly the condition under which we'll\n"
"say that the sequence `a (n)` **converges** to `L`.\n"
"\n"
"[![A Sequence Converging](images/SeqLim.jpg)](https://en.wikipedia.org/wiki/Limit_of_a_sequence)\n"
"\n"
"What makes this definition so powerful is its universality. The Machinist is essentially promising: 'Give me *any* tolerance requirement, no matter how stringent, and I can meet it -- though I might need more resources (larger `N`) for tighter specifications.'\n"
"\n"
"\n"
"Notice something else about the definition: It makes no mention of something happening \"eventually\", or \"at infinity\" or any other wishy-washy squirm words. We have traded the ambiguity of speaking about infinity for the precision of existential and universal quantifiers. No more hand-waving about what happens \"as `n` gets large\" - instead, we have a concrete challenge: given *any* tolerance `Îµ`, can you find a specific threshold `N`? *That* idea was the key breakthrough that allowed Calculus to enter the realm of rigorous mathematics.\n"
"\n"
"In Lean, the definition is written like so:\n"
"\n"
"`def SeqLim (a : â„• â†’ â„) (L : â„) : Prop :=\n"
"  âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, |a n - L| < Îµ`\n"
"\n"
"This syntax should be familiar from the `have` tactic you already know and love.\n"
"The special symbol `def` (instead of `have`) means that we're about to define something, and\n"
"`SeqLim` is its name (for squence limit, of course; but we could have called it whatever we want). Then our assumptions are a sequence `a : â„• â†’ â„` and\n"
"some real number `L : â„`. Then after the colon `:` goes our output, which in this case is `Prop`, that is, a statement (proposition) that can be true or false. So `SeqLim` is really a function that takes a sequence and hypothetical limiting value, and returns true or false based on whether\n"
"the condition is satisfied. Then comes a colon-equals `:=`, after which the\n"
"exact condition to be tested is specified. And the condition is what we already said, for all epsilon, yadda yadda. The big difference is that you can write `have` inside a proof, but you can't write `def` inside a proof;\n"
"`def` is reserved for making global definitions that\n"
"can be referenced forever once they're introduced.\n"
"Notice that on the right hand side, the list\n"
"of Definitions now includes `SeqLim`, and, as usual,\n"
"if you forget what it means, you can click on it for a reminder.\n"
"\n"
"Let's try out the definition in practice!\n"
"\n"
"**Your Task**\n"
"\n"
"Prove that the constant sequence converges to the same constant.\n"
"That is, suppose that you have a sequence `a : â„• â†’ â„`, and there's a real number\n"
"`L`, and a hypothesis that, for all values of `n`, we have  `a (n) = L`; then prove that `a` does converge, and converges to `L`. This is the simplest possible case: if our 'factory' always produces the exact target value `L`, then we can meet any tolerance requirement immediately!\n"
"\n"
"You may find useful a new tactic called `change`. It allows you to replace a goal (or hypothesis) by\n"
"something that is definitionally equal to it. In our example here,\n"
"You will see the goal as `SeqLim a L`. What are you supposed to do with that,\n"
"how can you make progress? Well, if you remember how `SeqLim` is defined,\n"
"then you can replace the goal with the definition, by writing\n"
"\n"
"`change âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, |a n - L| < Îµ`\n"
"\n"
"Lean will then change the goal to its definition.\n"
"Remember that `Îµ`, `N`, and `n` are all dummy variables\n"
"here, so you can have some fun:\n"
"\n"
"`change âˆ€ Alice > 0, âˆƒ Bob : â„•, âˆ€ blah â‰¥ Bob, |a blah - L| < Alice`\n"
"\n"
"This may come in handy later. (Not Alice and Bob *per se*, but the ability to give better names for dummy variables, so as not to clash with already existing variable names...)\n"
"\n"
"**âš ï¸âš ï¸âš ï¸ CAUTION âš ï¸âš ï¸âš ï¸** Remember how Lean *must* have space after a function name, it won't accept `f(x)` but instead requires `f (x)`? Well... it's the other way around for absolute\n"
"values. Lean won't accept a space after an absolute value.\n"
"So if you write `| a n - L|`, you'll get an error message.\n"
"Same with `|a n - L |` -- the space at the end is the problem. Sorry! I didn't write the syntax.\n"
"\n"
"**Normalizing Numerical Values**: And one last tactic you might also find useful is `norm_num` (for normalizing numerical values); it evaluates numerical expressions and proves equalities/inequalities involving concrete numbers. For example, if you're stuck with an `|0|` at some point,\n"
"and you want to convert it to plain old `0`, try calling `norm_num`.\n"
"\n"
"Ok, get to it!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Write `rfl` since we're proving that something equals itself."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Try starting with `change âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, |a n - L| < Îµ`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The `intro` tactic introduces variables and hypotheses from âˆ€ statements or implications."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Write `ring_nf` to expand and simplify both sides algebraically."
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
msgid "Problem 3"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Prove that the constant sequence converges to its constant value.\n"
"This is the Machinist's dream scenario: we're already producing exactly what's required!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "**BIG BOSS LEVEL**: This problem requires all the tactics you've learned!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "Lecture 2: Newton's Computation of Ï€"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The `specialize` tactic applies a universal statement in a hypothesis to a specific value."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "If there exists a point where f equals 2, then there exists a point where fÂ² equals 4."
msgstr ""

#: Game
msgid "# Welcome to Real Analysis, The Game!\n"
"\n"
"This course is currently being developed for Rutgers University Math 311H by [Alex Kontorovich](https://math.rutgers.edu/~alexk). Please email alex.kontorovich@rutgers.edu for suggestions/corrections,\n"
"or better yet, post a PR/issue to\n"
"https://github.com/AlexKontorovich/RealAnalysisGame.\n"
"\n"
"This course takes you through an Introduction to the Real Numbers, rigorous Îµ-Î´ Calculus,\n"
"and basic Point-Set Topology.\n"
"\n"
"To get started, click on\n"
"**\"Level 1: The Story of Real Analysis\"**, and good luck!"
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
msgid "# Problem 1\n"
"\n"
"We found in Lecture 2 that Newton's Binomial Theorem gave the expansion\n"
"\n"
"$\n"
"\\sqrt{1+x}\\approx\n"
"1\n"
"+\\frac{1}{2}x\n"
"-\\frac{1}{8}x^2\n"
"+\\frac{1}{16}x^3\n"
"-\\frac{5 x^4}{128}+\\cdots\n"
"$\n"
"\n"
"to fourth order.\n"
"Work out the next term in the expansion. This will be a constant `c` with the property that the polynomial\n"
"\n"
"$\\left(1  +\\frac{1}{2}x\n"
"-\\frac{1}{8}x^2\n"
"+\\frac{1}{16}x^3\n"
"-\\frac{5 x^4}{128} + c \\cdot x^5 \\right)^2 - (1 + x)$\n"
"\n"
"only has terms $x ^ 6$ or higher. (We don't *yet* have a way of saying that in Lean, so I have to give you the expansion explicitly.)"
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
msgid "# Problem 3\n"
"\n"
"You've just learned to add any necessary\n"
"auxiliary\n"
"facts to the list of hypotheses via the\n"
"`have` tactic.\n"
"In this problem,\n"
"you might find the following new idea useful.\n"
"\n"
"You already know that if you\n"
"have a hypothesis `h : X = Y`, and the Goal\n"
"contains `X`, then if you `rewrite [h]`,\n"
"then any instances of `X` in the goal\n"
"get replaced by `Y`.\n"
"But what if you have another hypothesis `h2`,\n"
"and you want to replace `X`'s in `h2` by `Y`s, what should you do then?\n"
"Elementary, my dear Watson!\n"
"You simply type:\n"
"\n"
"`rewrite [h] at h2`.\n"
"\n"
"So the syntax is `rewrite [h]` as before, then\n"
"the word `at`, and finally the name of the\n"
"hypothesis where you want the rewriting to happen.\n"
"Similarly, you can say `ring_nf at h2`,\n"
"and any algebra in hypothesis `h2` will be put into normal form.\n"
"\n"
"Now you should be able to solve this problem!"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "Pset 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Now write `specialize hf t_pos` feed in the proof that `t > 0`; then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `change` tactic changes a goal to something definitionally equal to it. If the definition of `X` is `Y`, that is, `X := Y`, and the Goal is `X`, you can write `change Y` and the Goal will change to `Y`. You can also\n"
"do this at a hypothesis; if you have a hypothesis `h : X`, you can write `change Y at h`, and `h` will change to `h : Y`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Perfect! You've completed your first Lean proof involving real numbers.\n"
"\n"
"Remember: the `apply` tactic is used when you have what you need to prove the goal. Look at the top right: your list of tactics now includes `apply`, and if you forget how it works or what it does, just click on it for a reminder."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# The Final Challenge\n"
"\n"
"Congratulations! You've learned many fundamental tactics for mathematical reasoning in Lean:\n"
"- `apply hypothesisName` for when a hypothesis matches the goal\n"
"- `rfl` for reflexivity (proving `X = X`)\n"
"- `rewrite [hypothesisName]` for rewriting using equalities\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for providing witnesses to existence statements in goals\n"
"- `intro` for handling universal quantifiers in goals\n"
"- `specialize` for applying universal statements to specific values in hypotheses\n"
"- `choose value hypothesisOnValue using ExistentialHypothesis` for extracting information from existence statements in hypotheses\n"
"\n"
"Here's a little \"Universal/Existential Quantifier Cheat Sheet\":\n"
"\n"
"|           | âˆ€        | âˆƒ      |\n"
"|-----------|----------|--------|\n"
"| **Goal**  | `intro`    | `use`    |\n"
"| **Hypothesis** | `specialize` | `choose` |\n"
"\n"
"Now it's time for your first **Big Boss** - a problem that requires you to use almost ALL of these tactics in a single proof!\n"
"\n"
"**Lecture 1 Big Boss**\n"
"Given a function `f` and information about its behavior, prove a complex statement that involves existence, universals, algebra, and rewriting.\n"
"\n"
"This is what real mathematical proofs look like - a careful orchestration of multiple reasoning steps. You've got this! Use everything you've learned.\n"
"\n"
"**Extra Challenge**\n"
"If you want to *really* challenge yourself, play this level \"blind\". Write the assumptions and goal down on paper, close the computer, solve it by hand, keeping track *in your mind* of what happens to the game board after each command, and only once youâ€™ve worked it all out, open the computer and see if Lean accepts your solution.\n"
"\n"
"Why do you think that this would this be a good thing to do?\n"
"\n"
"In general, I hope your *goal* in taking this course is to make your \"Real Analysis Brain Muscles\" stronger. By the end, you should be *really good* at\n"
"solving Real Analysis problems on paper, where you don't have Lean showing\n"
"you the Goal State after every move.\n"
"More broadly, the purpose of learning to solve Real Analysis problems is to learn to *think*, clearly, precisely. Strengthening your ability to work with pen and paper (or just mentally) directly transfers to *any* other context where you're exploring ideas, wrestling with complicated arguments, or trying to communicate clearly to others.\n"
"\n"
"An LLM could easily work through all these Lean levels by pattern matching and logical manipulation - just as you could solve multiplication problems by plugging them into a calculator instead of memorizing your times tables. But that completely defeats the purpose of the exercise, which is to rewire your brain and build mathematical intuition. It's like deciding that you want to bench press 200 pounds, loading up the bar, and then using a forklift to lift it for you while you stand underneath - you might have moved the weight, but you haven't gotten any stronger. The real value isn't in producing correct proofs, it's in the cognitive transformation that happens when you *struggle* through the reasoning yourself, building the mental pathways that let you see mathematical structure intuitively."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "There exists a real number that makes this binomial expansion work."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "If you're struggling to prove that `2 ^ 2 = 4`, it's\n"
"a basic fact in a *ring*..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The use tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The `rewrite` tactic replaces the left-hand side of an equality with the right-hand side in the goal. The syntax is `rewrite [hypothesis_name1, hypothesis_name2, etc]`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Excellent! You've learned the `ring_nf` tactic.\n"
"\n"
"This tactic is incredibly powerful for algebraic manipulations. It automatically handles all the tedious algebra that would take many steps to do by hand.\n"
"\n"
"Your toolkit now includes:\n"
"- `apply hypothesis_name` for when a hypothesis matches your goal\n"
"- `rfl` for proving something equals itself\n"
"- `rewrite [hypothesis_name]` for rewriting using equalities\n"
"- `ring_nf` for algebraic simplifications and expansions\n"
"\n"
"As we move into real analysis proper, you'll find that `ring_nf` is invaluable for dealing with polynomial expressions, which appear everywhere in calculus!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `norm_num` tactic can normalize numerical constants and functions of them."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For a sequence `a : â„• â†’ â„` and a real number `L : â„`, we say that `SeqLim a L` holds if: for every `Îµ > 0`, there exists `N : â„•` such that for all `n â‰¥ N`, we have `|a n - L| < Îµ`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The specialize tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Introduction to Lean"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "Show that there exists a constant `c` so that, for any real numbers `x` and `y` with `x ^ 2 + y ^ 2 = 2` and `x * y = 1`, we have `(x + y) ^ 2 = c`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "The `choose` tactic extracts a witness from an existence statement in a hypothesis."
msgstr ""

#: Game
msgid "A First Course in Real Analysis"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The rw tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "If we know that $x = 5$, then we can prove that $x = 5$."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "# When things are identical to themselves\n"
"\n"
"Sometimes in mathematics, we need to prove that something equals itself. For example, we might need to prove that $x^2 + 2y = x^2 + 2y$.\n"
"\n"
"This isn't quite the same as our previous exercise. There, we had a hypothesis `h` that told us `x = 5`, and we used `apply h` to prove the goal `x = 5`.\n"
"\n"
"But now we don't have any hypothesis that says `x^2 + 2y = x^2 + 2y`. We're just being asked to prove that some expression equals itself. We can't say `apply something` because there's no `something`.\n"
"\n"
"Instead, we will use what mathematicians call the *reflexive property* of equality: everything is equal to itself. In Lean, if you get to a situation where you're trying to prove an equality, and the two things on both sides are *identical*, then the syntax is to give the command `rfl` (short for \"reflexivity\").\n"
"\n"
"Try it out!"
msgstr ""

#: Game
msgid "*An Introduction to Formal Real Analysis - Interactive Edition*\n"
"\n"
"## About this Course\n"
"\n"
"This course follows the historical crises that forced mathematicians to rebuild\n"
"mathematics from the ground up in the 19th century. You'll learn why concepts\n"
"like Îµ-Î´ definitions became necessary and how to use them to do advanced calculus.\n"
"\n"
"## Credits\n"
"\n"
"* **Course Design:** By Alex Kontorovich alex.kontorovich@rutgers.edu\n"
"* **Interactive Implementation:** Lean 4 Game Engine\n"
"* **Mathematical Content:** Following Rudin, Stein-Shakarchi, Abbot, etc."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "The obtain tactic"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
msgid "# Problem 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "The `apply` tactic solves a goal when one of the hypotheses is the same as the goal. The syntax is `apply hypothesis_name`"
msgstr ""

#: Game
msgid "An Introduction to (Formal) Real Analysis"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "# Theorem Prover Software\n"
"\n"
"In this course, we will be using a \"proof assistant\" called Lean. This is software that checks that our proofs prove *exactly* what we\n"
"claim they prove. It has other really cool pedagogical features that we'll get to later.\n"
"It will take a little while to get used to the syntax, so until we're comfortable, we'll intersperse exercises teaching Lean with exercises teaching Real Analysis. Pretty soon all the exercises will just be about Real Analysis.\n"
"\n"
"\n"
"For this first exercise, we have a hypothesis that we called `h` (but we could've called it anything, like `x_eq_5`, or `Alice`) that says a real number `x` equals 5. Our goal is to prove that `x` equals 5.\n"
"This shouldn't be very hard, but if you don't know\n"
"the command, you'll be out of luck. Our goal is to\n"
"prove the same statement as one of the hypotheses.\n"
"To solve that goal, the syntax is to write `apply`, then a space, and then the name of the hypothesis which matches the goal."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
#: Game.Levels.L2Pset.L2Pset2
msgid "Problem 2"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "# Extracting information from existential quantifiers\n"
"\n"
"Now let's learn the counterpart to `use`. You know that if you have `âˆƒ` in the goal, you write `use` to provide a specific value.\n"
"\n"
"But suppose you have a *hypothesis* that says \"there exists a real number `c` such that `f (c) = 2`\". In Lean, this looks like:\n"
"`h : âˆƒ (c : â„), f c = 2`\n"
"\n"
"And say you want to prove that \"there exists a real number `c` such that `(f c)^2 = 4`\".\n"
"\n"
"Again, you can't just say `apply h` because these are different statements.\n"
"If you know from `h` that at least one such `c` exists, how do you *choose* one?\n"
" The name of this command is... `choose`.\n"
"\n"
"The syntax for `choose` is as follows:\n"
"\n"
"`choose c hc using h`.\n"
"\n"
"You need to give a name to both the value of `c`, and to the hypothesis with which `c` is bundled. Here we named it `hc` (a hypothesis about `c`).\n"
"\n"
"You should be able to figure out how to solve the goal from here."
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
msgid "Solve the problem"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "# Problem Set 1\n"
"\n"
"Just because it's a problem set doesn't mean\n"
"you can't learn new things..."
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "# Problem 5\n"
"\n"
"You've learned about adding hypotheses with `have`, and that you can call tactics not\n"
"just to act on the Goal, but  also on hypotheses, via adding `at HypothesisName` at the end.\n"
"You also know that calling the `rewrite` tactic with a hypothesis `h : X = Y` takes the *left hand side* `X` and replaces it by `Y`. But what if you needed instead to replace `Y`'s by `X`'s? We call that \"backwards rewriting\". The syntax for that is:\n"
"\n"
"`rewrite [â† h]`\n"
"\n"
"or\n"
"\n"
"`rewrite [â† h] at h2`\n"
"\n"
"to do it at some other hypothesis, `h2`. You get the backwards arrow by typing \\left,\n"
"that is, the backslash, then the word `left`, and then a space.\n"
"\n"
"You may (or may not) find that useful in this problem."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For any sequence `a : â„• â†’ â„` and constant `L : â„`, and\n"
"hypothesis `h : âˆ€ n, a n = L`, the theorem `ConstLim`\n"
"proves that `SeqLim a L`, that is, the (constant) sequence `a` converges to `L`."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "# Problem 2\n"
"\n"
"In this problem you are asked to show that there is some `c` so that `(x + y) ^ 2 = c`, given that\n"
"`x * y = 1` and `x ^ 2 + y ^ 2 = 2`.\n"
"\n"
"You will likely have a hard time solving this problem as is.\n"
"You surely can work out what value of\n"
"`c` you need. But if you try\n"
"`ring_nf`, you won't have control over\n"
"how the \"normal form\" chooses to\n"
"express things. In fact, the\n"
"left-hand side, `(x + y) ^ 2` will\n"
"turn into `x * y * 2 + x ^ 2 + y ^ 2`,\n"
"which is parsed in this order:\n"
"\n"
"`(((x * y) * 2) + x ^ 2) + y ^ 2`\n"
"\n"
"This means that you *will* be able to\n"
"`rewrite [h2]` successfully,\n"
"but then you will *not* be able to rewrite by `h1`, because the (invisible) parentheses  go the wrong way. (Hint: If you want to know how things are grouped but don't see parentheses, you can hover your cursor over the text in the Goal State, and Lean will show you the groupings. Try it!)\n"
"\n"
"Now, in natural language, there are times when you might want to\n"
"record an auxiliary fact: \"let's\n"
"*have* the fact that such and such ...\". The Lean\n"
"syntax for this is as follows:\n"
"\n"
"`have NewFactName (Assumptions) : Conclusion := by Proof`\n"
"\n"
"That is, you first write `have`; then give\n"
"the new hypothesis a name; then include any\n"
"assumptions, like `(x : â„)`, meaning, `x`\n"
"is a real number, etc (the symbol `â„` is written with a backslash, then capital `R`, then space); then you put a colon,\n"
"and then state the conclusion; then you\n"
"put a colon-equals and the word `by`; and finally you give the proof.\n"
"\n"
"For example, if you wanted to declare\n"
"the new fact that, say, for any real `u` and `v`,\n"
"\n"
"`(u + v) ^ 2 = (u ^ 2 + v ^ 2) + 2 * (u * v)`\n"
"\n"
"and you wanted to call this fact `huv` (a hypothesis on `u` and `v`),\n"
"and you wanted to prove this fact by\n"
"invoking the ring normal form tactic,\n"
" then you would give Lean the command:\n"
"\n"
"`have huv (u v : â„), (u ^ 2 + v ^ 2) + 2 * (u * v) := by ring_nf`\n"
"\n"
"This will add to your list of hypotheses\n"
"the fact: `huv : âˆ€ (u v : â„), (u ^ 2 + v ^ 2) + 2 * (u * v)`.\n"
"\n"
"Something like this (if not exactly this)\n"
"will be useful to you in solving this problem."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The binomial expansion: $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$."
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "Pset 2"
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
msgid "Problem 4"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "While you may see `0 < Îµ` in the goal and `Îµ > 0` in the hypothesis `hÎµ`, Lean will still know that these two things are exactly the same..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "# A First Course in Real Analysis\n"
"\n"
"You may want to pull the left-most slider all the way to the right; what follows is a discussion\n"
"between \"Socrates\" and \"Simplicio,\" which hopefully  explains what it is we're trying to do here.\n"
"\n"
"**SIMPLICIO:** What is \"Real Analysis\"?\n"
"\n"
"**SOCRATES:** Oh, it's just Calculus, but done \"right\".\n"
"\n"
"**SIMPLICIO:** Huh? Why does Calculus need a new name? What's wrong with it?\n"
"\n"
"**SOCRATES:** Well, nothing really. Quick: what's a derivative?\n"
"\n"
"**SIMPLICIO:** Easy! If I have a function $f : \\R \\to \\R$ and it's differentiable at $x$, then the\n"
"derivative is $f'(x) := \\lim_{h \\to 0}\\frac{f(x+h) - f(x)}{h}$. This represents the \"instantaneous\" slope\n"
"of the graph of the function $y=f(x)$ at the point $(x, f(x))$.\n"
"[![derivative](images/Deriv.jpg)](https://en.wikipedia.org/wiki/Derivative)\n"
"\n"
"**SOCRATES:** Very good! And tell me please, what is an integral?\n"
"\n"
"**SIMPLICIO:** That's easy, too! If you want to integrate our function $f$ along an\n"
"interval, $[a, b]$, say, you pretend that you have infinitely many, infinitely small rectangles, work out their\n"
"areas as base times height, and add them up:\n"
"$\\int_a^b f(x)dx := \\lim_{N\\to\\infty} \\sum_{j=1}^N \\frac{b-a}{N} f\\left(a + j\\frac{b-a}{N}\\right)$\n"
"[![integral](images/Integral.jpg)](https://en.wikipedia.org/wiki/Integral)\n"
"\n"
"**SOCRATES:** Great. And what are the two Fundamental Theorems of Calculus?\n"
"\n"
"**SIMPLICIO:** These too are easy! The first one says that if you make a new function by integrating $f$\n"
"up to a variable amount, $x$, that is, let\n"
" $F(x) := \\int_a^x f(t)dt$, then the derivative of the new function is just $F'(x) = f(x)$.\n"
"\n"
"**SOCRATES:** And the second?\n"
"\n"
"**SIMPLICIO:**\n"
"The second one says that, conversely, if $F$ is an antiderivative of $f$, that is, $F'(x)=f(x)$, then\n"
"it's easy to work out the area under the curve, because\n"
" $\\int_a^b f(x)dx = F(b) - F(a)$.\n"
"So differentiation and integration are inverse operations!\n"
"\n"
"**SOCRATES:** Perfect. Now, here's the problem. You used words like \"limit\", \"infinitely many\", \"infinitely small\", and so on. What do they *actually* mean?\n"
"\n"
"**SIMPLICIO:** Oh, you know, it's when something  happens \"eventually\". You just have to get used to\n"
"the feel of it.\n"
"\n"
"**SOCRATES:** Hmm yes, I see. I agree that that's an OK way to think of it, for a while at least, and one that suited Newton (who\n"
"was quite uncomfortable with such words), and Leibniz (who was more care-free here), the two 17th century inventors of\n"
"calculus (if you don't count people like the ancient Greeks Eudoxus and Archimedes, or the 14th century Indian Madhava... but this isn't a history lesson). Leibniz taught the Bernoulli\n"
"brothers (the world's \"first AP Calc students\"!), who taught, among others, the Marquis de l'Hopital, and the great Leonhard Euler (the first \"Calc native\"), who taught the rest of us. All was going quite well... and then came the 19th Century.\n"
"[![NewtonLeibnizEudoxusArchimedesMadhavaBernoulliEuler](images/People.jpg)](https://en.wikipedia.org/wiki/History_of_calculus)\n"
"\n"
"**SIMPLICIO:** Huh? What happened in the 19th Century?\n"
"\n"
"**SOCRATES:** Well you see, a guy named Augustin-Louis Cauchy came along (roughly in the 1810s), and started making a fuss that we weren't really doing things perfectly \"rigorously\".\n"
"He set out to reprove the theorems of calculus using precise definitions rather than hand-waving.\n"
"He was making great progress, including proving statements like: the limit of continuous functions is continuous.\n"
"[![Cauchy](images/Cauchy.jpg)](https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy)\n"
"\n"
"**SIMPLICIO:** Sure, that sounds perfectly reasonable. A limit is a continuous process, so you do that to\n"
"continuous functions, and of course in the end you should get something continuous, too.  No?\n"
"\n"
"\n"
"**SOCRATES:** Well, the problem is that around the same time, a guy named Joseph Fourier was going around claiming\n"
" that he could add up a bunch of sines and cosines, and get basically any function he wants, including, say, the discontinuous sawtooth!\n"
"\n"
"**SIMPLICIO:** What?!\n"
"\n"
"**SOCRATES:** Look for yourself: Here's a graph of $\\sum_{n=1}^{100}\\frac1n \\sin(nx)$. As you take 100\n"
"out to infinity, Fourier claims that this will get\n"
"closer and closer to a sawtooth function!\n"
"[![Fourier](images/Fourier.jpg)](https://en.wikipedia.org/wiki/Joseph_Fourier)\n"
"\n"
"**SIMPLICIO:** Whoa. Wait, I can think of an even easier example: just look at the simplest family of\n"
"polynomials, $f_n(x) = x^n$, on the unit interval $[0,1]$. When you take high powers of any point\n"
"strictly less than $1$, that goes to $0$ in the limit, but powers of $1$ itself always stay at $1$.\n"
"So the limiting function is discontinuous, too! What the heck is going on here?\n"
"![Power Functions](images/Powers.png)\n"
"\n"
"\n"
"**SOCRATES:** Very good, Simplicio! Exactly right, between Fourier and Cauchy, they \"broke math\".\n"
" You break it, you buy it!\n"
"\n"
"**SIMPLICIO:** Ok, so what's the right answer, how *do* you do calculus rigorously?\n"
"\n"
"**SOCRATES:** Not so fast! Things got even worse, and by the mid-19th century, people realized that\n"
"we don't even know what the real numbers *are*!\n"
"\n"
"**SIMPLICIO:** What? What do you mean, what are they? Here they are right here: There's zero, and one, and $-2$, and $\\frac35$, and\n"
"$\\sqrt 2$, and $e$ and $\\pi$. What's the problem?\n"
"[![RealNumbers](images/RealLine.png)](https://en.wikipedia.org/wiki/Real_number)\n"
"\n"
"**SOCRATES:** Well, do you remember that you need something called the Intermediate Value Theorem\n"
"in calculus?\n"
"\n"
"**SIMPLICIO:** Sure, if you have a continuous function, and it goes from being negative to being positive,\n"
"then it has to cross zero at some point in between.\n"
"\n"
"**SOCRATES:** Very good. Tell me about the function $f : x \\mapsto x^2 - 2$. (We say: \"$f$ maps\n"
"$x$ to $x^2-2$\". Note that we write $f : \\R \\to \\R$ to mean that $f$ takes real numbers to real numbers, but\n"
"replace $\\to$ with $\\mapsto$ (see the tail on the second arrow?) when we want to say what happens to a particular input $x$ under the action of\n"
"$f$. Let me remind you that $x$ here is a dummy variable, so it's the same function if we'd said $f : u \\mapsto u ^ 2 - 2$.) In particular, what happens to $f$ on the rational numbers?\n"
"\n"
"**SIMPLICIO:** Ok, well if $x$ is a rational number, then so is $x^2$, and hence so is $x^2-2$.\n"
"So actually, we could say that $f : \\mathbb Q \\to \\mathbb Q$, that is, $f$ maps rational numbers to rational numbers.\n"
"Over the reals, the graph of $y=f(x)$ is a simple parabola.\n"
"But you'd asked me about the Intermediate Value Theorem. Hmm. When $x=0$, I know that $f(x)$ will\n"
"be $f(0)=0^2-2=-2$ which is negative. And when $x=2$, $f(2)=2^2-2=2$ which is positive.\n"
"\n"
"**SOCRATES:** Go on...\n"
"\n"
"**SIMPLICIO:** So there's a root of $f$ somewhere between $0$ and $2$. But the place where $f$ crosses the $x$-axis is at $x=\\sqrt2\\approx 1.41\\dots$.\n"
"\n"
"**SOCRATES:** And what did the Pythagoreans know about this number?\n"
"\n"
"**SIMPLICIO:** Supposedly one of them, Hippasus, figured out that $\\sqrt2$ is irrational, which ruined\n"
"their entire theory of geometry and form (they originally believed that *all* numbers were rational); legend has it\n"
"that Hippasus was drowned at sea for his herecy.\n"
"\n"
"**SOCRATES:** So...\n"
"\n"
"**SIMPLICIO:** So wait, if we just restrict to rational inputs, then this parabola is negative, and then\n"
"it's positive, and it *never* crosses zero?! But there's tons of rational numbers almost everywhere you look. So what makes the real numbers different from the\n"
"rational numbers, so that the Intermediate Value Theorem actually holds?\n"
"\n"
"**SOCRATES:** Ah! Now, my friend, we are ready to begin."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "# Universal statements\n"
"\n"
"In mathematics, we often need to prove statements that are true \"for all\" values of some variable. For example, we might want to prove: \"for all $\\varepsilon > 0$, we have $(\\varepsilon + 1)^2 = (\\varepsilon + 1)^2$.\"\n"
"(Of course the condition that `Îµ` be positive is mathematically superfluous, and is only here for pedagogical purposes.)\n"
"\n"
"If you're thinking that `rfl` will do the trick, that's a good idea, but it won't work, because the goal isn't (yet) an equality. So we need to do something else first.\n"
"\n"
"In Lean, as in mathematics, \"for all\" is written using `âˆ€`; this is called the *universal quantifier*, and is gotten by typing \\forall, that is, backslash, then `forall`, then a space. In Lean, this goal looks like so:\n"
"\n"
"`âˆ€ Îµ > 0, (Îµ + 1)^2 = (Îµ + 1)^2`.\n"
"\n"
"(Note that to write an epsilon in Lean, you just type \\\\e, that is, backslash, then `e`, then space.)\n"
"\n"
"To prove a \"for all\" statement, you need to show that it's true for an arbitrary element. In English, you would say: give me an arbitrary `Îµ`, and give me the fact that it's positive (we can give that fact a name, like `hÎµ`, since it's a hypothesis about `Îµ`, or perhaps an even more descriptive name like `Îµ_pos`, since the hypothesis is the positivity of `Îµ`). Note that `Îµ` here is a dummy variable, and we could choose to name it something else on the fly. In English, we might say: give me some `Îµ`, but I want to call it `Alice`; then give me the fact that `Alice` is positive, and my goal will be to prove that `(Alice + 1)^2 = (Alice + 1)^2`. If we were more polite, we might replace \"give me\" above with \"introduce\", like:\n"
"introduce an `Îµ`, and introduce the fact, call it `hÎµ`, that `Îµ` is positive.\n"
"\n"
"In Lean, the syntax for this is the command `intro`, followed by whatever name you want to give a dummy variable or a hypothesis.\n"
"\n"
"So: when you see a goal that starts with `âˆ€`, you can write `intro` to \"introduce\" the variable. For example:\n"
"- `intro Îµ` introduces the variable Îµ. But look at the goal state now! It changes to: `Îµ > 0 â†’ (Îµ + 1)^2 = (Îµ + 1)^2`. So we're not done introducing things.\n"
"- Then `intro hÎµ` introduces the hypothesis that `Îµ > 0` (and again, you can call the hypothesis whatever you want; try `intro Îµ_pos` instead).\n"
"\n"
"After using `intro` twice, the goal will become one that you\n"
"should know how to solve.\n"
"\n"
"If you want to be really slick, you can combine the two `intro` commands into\n"
"one: `intro Îµ hÎµ`. But don't feel obliged."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
msgid "Done."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The Convergence of a Sequence"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "# The Mathematical Revolution of 1666\n"
"\n"
"**SIMPLICIO:** I heard that Newton had a really cool way of calculating Ï€. Can you tell me about it?\n"
"\n"
"**SOCRATES:** Certainly. It begins around 1665-1666, when Newton was turning 23 years old. Anything significant about that year?\n"
"\n"
"**SIMPLICIO:** Isn't that Newton's  \"annus mirabilis\",  year of miracles? If I recall correctly, he was forced to leave Cambridge due to an outbreak of  the Great Plague, and made his most groundbreaking discoveries (calculus, optics, gravitation, etc) while quarantining in isolation at his family home in Woolsthorpe.\n"
"\n"
"**SOCRATES:** Exactly right. And one of the first things he discovered in that year was a  new version of\n"
"the Binomial Theorem. Tell me, please,  what can one say about\n"
"$(1 + x) ^ n$?\n"
"\n"
"**SIMPLICIO:** Sure thing, if you multiply $(1+x)^n$ all out, you get\n"
"$ \\binom{n}{0} + \\binom{n}{1}x + \\binom{n}{2}x^2 + \\cdots + \\binom{n}{n}x^n$. Here $\\binom{n}{k}$ is the \"binomial coefficient\", the number of ways of choosing $k$ things from a bag of $n$ things. Explicitly, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. These are just the numbers in Pascalâ€™s Triangle, and you can easily read off the $n$-th row.\n"
"[![Pascal's Triangle](images/Yanghui_triangle.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"\n"
"**SOCRATES:** Excellent! And do you know sigma notation?\n"
"\n"
"**SIMPLICIO:** I think so. I couldâ€™ve written  that same thing as $\\sum_{k=0}^{n} \\binom{n}{k} x^k$. In general, if you have some function $f: \\mathbb{N} \\to \\mathbb{R}$, and you want express $f(a)+f(a+1)+â€¦+f(b)$, that is, the sum of $f(k)$ as $k$ ranges from some integer $a$ up to some other integer $b$, you can write it as $\\sum_{k=a}^{b} f(k)$.\n"
"\n"
"**SOCRATES:** Very good.  So we have $(1+x)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^k$. Now, would you allow me to write this as a sum going all the way out to infinity?\n"
"$(1+x)^n = \\sum_{k=0}^{\\infty} \\binom{n}{k} x^k$\n"
"\n"
"**SIMPLICIO:** Hmm. Ok, I think I see what youâ€™re getting at: Pascalâ€™s Triangle has implied zeros everywhere outside, so $\\binom{n}{k}$ is just zero once $k>n$. So youâ€™ve written it as an infinite sum, even though it secretly terminates after finitely many terms. But what purpose does extending it serve?\n"
"\n"
"**SOCRATES:** Well, let me ask you this: can you think of any way of making sense of this formula when $n=-1$?\n"
"\n"
"**SIMPLICIO:** Huh? You canâ€™t use binomial coefficients. How do you choose 3 things from -1 things, that makes no sense!\n"
"\n"
"**SOCRATES:** Ok, sure, but so many great discoveries in mathematics occur when you realize a way to **break the rules**, and follow some pattern **past** its intended... limit (no pun intendedâ€¦). Put yourself in Newtonâ€™s shoes, if you can; what might a genius like him come up with?\n"
"\n"
"**SIMPLICIO:** Well, we do have this other formula for binomial coefficients, not in terms of combinatorics, but just as factorials, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. That still doesnâ€™t help because what the heck is $(-1)!$ supposed to be?! Oh, but wait! We can also write this as:\n"
"\n"
" $\\binom{n}{k} = \\frac{n(n-1)(n-2)\\cdots(n-k+1)}{k!}$\n"
"\n"
"And in this way, we â€œbypassâ€ the issue of dealing with $(-1)!$, and just go straight to â€œnormalâ€ numbers.\n"
"\n"
"**SOCRATES:** Can you please write this using product notation?\n"
"\n"
"**SIMPLICIO:** Sure, it's just like summation notation but with a $\\Pi$:\n"
"\n"
" $\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=1}^{k}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Whoops, are you sure about those bounds in the product?\n"
"\n"
"**SIMPLICIO:** Argh! It's so easy to make a silly mistake.\n"
"After writing down the formula, I should have\n"
"checked that I got the right start and end values;\n"
"the counter $\\ell$ should go from $0$ to $k-1$, not from $1$ to $k$.  Is this better?\n"
"\n"
"$\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Perfect. Go on.\n"
"\n"
"**SIMPLICIO:** Ok, so if we agree to follow this pattern, then we get:\n"
"\n"
"- $\\binom{-1}{0} = 1$, which makes sense because any row of Pascal's triangle starts with at $1=\\binom{c}{0}$; then\n"
"\n"
"- $\\binom{-1}{1} = (-1)/1! = -1$, which also makes sense because the next term in the \"$c$th row\" of Pascal's triangle is always\n"
"$\\binom{c}{1} = c$; then we get:\n"
"\n"
"- $\\binom{-1}{2} = (-1)(-2)/2! = +1$,\n"
"\n"
"- $\\binom{-1}{3} = (-1)(-2)(-3)/3!=-1$.\n"
"\n"
"Ok so I see the pattern:\n"
"it just alternates between $+1$ and $-1$, so the series goes:\n"
"\n"
" $(1+x)^{-1} = 1 - x + x^2 - x^3+x^4-x^5+\\cdots$.\n"
"\n"
"**SOCRATES:** Very good! But does this formula make any actual\n"
"*sense*? How might you test it?\n"
"\n"
"**SIMPLICIO:** Ok, if that series is supposed to \"represent\"\n"
"$1/(1+x)$, then if I multiply the whole thing by\n"
"$(1+x)$, I should just get $1$. Let's try it:\n"
"\n"
"$(1+x)(1 - x + x^2 - x^3+x^4-x^5+\\cdots) = ?$\n"
"\n"
"I'll first multiply everything by $1$, then by $x$, and add them all up.\n"
"\n"
"$(1 - x + x^2 - x^3+x^4-x^5+\\cdots) + (x - x^2 + x^3- x^4+x^5\\cdots)$\n"
"\n"
"Ok, so if I rearrange terms, then everything cancels out, and only the leading $1$ remains. Great!\n"
"\n"
"**SOCRATES:** Interesting. And are you \"allowed\" to rearrange terms like that?\n"
"\n"
"**SIMPLICIO:** Well.... why not?\n"
"\n"
"**SOCRATES:** Ok, nevermind that for now,\n"
"you seem to be satisfied that it makes sense to say\n"
"that the series\n"
"$1 - x + x^2 - x^3+x^4-x^5+\\cdots$ \"converges\" (again, whatever that means) to $(1+x)^{-1}$.\n"
"\n"
"**SIMPLICIO:** Come to think of it, I knew this already;\n"
"it's just the geometric series! I know that\n"
"\n"
"$1+\\lambda + \\lambda^2+\\lambda^3+\\cdots$\n"
"\n"
"adds up to $1/(1-\\lambda)$, and the series we have just replaces $\\lambda$ with $-x$.\n"
"\n"
"**SOCRATES:** Yes, very good.\n"
"And where might this \"belong\" in Pascalâ€™s triangle?\n"
"\n"
"**SIMPLICIO:**\n"
"Holy cow! Did we just discover an extension of the triangle, going â€œupâ€?!\n"
"[![Pascal's Triangle, Extended](images/PascalM1.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:**\n"
"Indeed, and we can in fact continue this pattern for $n=-2,\n"
"-3, -4,$ and so on. I'll let you work it out yourself, but we actually\n"
"get a *whole other* Pascal's triangle (with some negative signs) *above* the standard one!\n"
"[![Pascal's Triangle, Extended](images/PascalMn.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"See how it still follows the usual rule, that the two numbers above and to the left or right add to the value just below them?\n"
"\n"
"But let's try something even more exotic. Can you make\n"
"the Binomial Theorem work when $n=1/2$?\n"
"\n"
"\n"
"**SIMPLICIO:** Whoa, $n = 1/2$? That's... really pushing it! But let me try using the same formula. So $\\binom{1/2}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(1/2-\\ell)$. Let me work out the first few terms:\n"
"\n"
"- $\\binom{1/2}{0} = 1$ (as always)\n"
"\n"
"- $\\binom{1/2}{1} = (1/2)/1! = 1/2$ (again, matches the pattern we already knew)\n"
"\n"
"- $\\binom{1/2}{2} = (1/2)(-1/2)/2! = -1/8$\n"
"\n"
"- $\\binom{1/2}{3} = (1/2)(-1/2)(-3/2)/3! = 1/16$\n"
"\n"
"- $\\binom{1/2}{4} = \\frac{(1/2)(-1/2)(-3/2)(-5/2)}{4!} =  -\\frac{5}{128}$\n"
"\n"
"So $(1+x)^{1/2} = 1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots$\n"
"\n"
"But wait -- this is supposed to be $\\sqrt{1+x}$?!\n"
"\n"
"**SOCRATES:** Again, go into Newton's thinking: how might he go about justifying whether this formula makes any sense?\n"
"\n"
"**SIMPLICIO:** Oh, ok, I think I see! If we square the formula and multiply everything out, I guess we're supposed to get $1+x$ -- that would justify calling the series $\\sqrt{1+x}$.\n"
"\n"
"**SOCRATES:** Go for it!\n"
"\n"
"**SIMPLICIO:** Ok, so I want\n"
"\n"
"$\\left(1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots\\right)^2$\n"
"\n"
"That means squaring every term, and also adding twice every product of distinct pairs of terms.\n"
"\n"
"**SOCRATES:** Right. Can you think of a good way of keeping track of everything?\n"
"\n"
"**SIMPLICIO:** Oh, I know! Let's group things by the power of $x$ involved. The first one is easy: $x^0=1$, which you only get from squaring the first term. So that coefficient is $1$.\n"
"\n"
"For the coefficient of $x^1$, I can't square anything involving $x$'s, so I\n"
"can only multiply the $x$ term by the constant term, and of course double it.\n"
"That's just $2 \\times 1 \\times \\frac{1}{2}x = x$. So the coefficient of $x$ is $1$.\n"
"\n"
"For $x^2$, I get two contributions  from constant times quadratic: $2 \\times 1 \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{4}x^2$ and also from the square of the linear term: $\\left(\\frac{1}{2}x\\right)^2 = \\frac{1}{4}x^2$. So the total coefficient is $-\\frac{1}{4} + \\frac{1}{4} = 0$.\n"
"\n"
"Let's try a few more. To get $x^3$, I need:\n"
"- $2 \\times 1 \\times \\frac{1}{16}x^3 = \\frac{1}{8}x^3$ (constant times the $x^3$ term)\n"
"- $2 \\times \\frac{1}{2}x \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{8}x^3$ (the $x$ term times the $x^2$ term)\n"
"\n"
"So the total coefficient of $x^3$ is $\\frac{1}{8} - \\frac{1}{8} = 0$.\n"
"\n"
"This is amazing! It really seems like all the higher-order terms are canceling out perfectly. I bet that will keep happening, and we'll just get the square to come out to exactly $1+x$; the formula really works!\n"
"\n"
"So wait, now we get a whole other row in Pascal's triangle, *between* rows $0$ and $1$?!\n"
"\n"
"[![Pascal's Triangle](images/PascalM12.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:** Beautiful, isn't it!\n"
"\n"
"**SIMPLICIO:** Wait, this is all much simpler than I'm making it. Isn't this just the same thing as the Taylor expansion about $x=0$ of the function $f(x)=\\sqrt{1+x}$?\n"
"I already know how to do this from Calculus.\n"
"\n"
"**SOCRATES:** Yes, very good; but Brook Taylor (of Taylor series) did not prove his general theorem until 1715, a few decades after\n"
"Newton's computation of $\\pi$.\n"
"\n"
"Now, suppose you wanted to compute something like $\\sqrt 3$ -- can you think of a way of doing it using this formula?\n"
"\n"
"**SIMPLICIO:** Hmm the function is $\\sqrt {1+x}$, so I guess I want to set $x=2$. Then I get:\n"
"\n"
"$\\sqrt {1+2} = 1 + \\frac{1}{2}(2) - \\frac{1}{8}(2)^2 + \\frac{1}{16}(2)^3 -\n"
"\\frac{5}{128}(2)^4 + \\cdots$\n"
"\n"
"Adding up these five terms comes out to $11/8 = 1.375$, not so close to $\\sqrt3\\approx1.73$. And the individual terms\n"
"are not so small, for instance, the last one, $\\frac{5}{128}(2)^4 = 5/8 = 0.625$.\n"
"\n"
"**SOCRATES:** Well, sure, if you set $x$ to be large, like $x > 1$, then the powers of $x$ are also larger and larger (and exponentially so!)... Can you think of something else you could do?\n"
"\n"
"**SIMPLICIO:**\n"
"Ah, I think I see! I know that\n"
"$3$ is near $4$, which is a perfect square. So what if we write\n"
"\n"
"$\\sqrt 3 = \\sqrt{4-1} = \\sqrt{4(1-\\frac14)}=2\\sqrt{1-\\frac14}$\n"
"\n"
"So now if I apply our formula with $x=-1/4$ (which is less than one!), I guess I'll get:\n"
"\n"
"$\\sqrt3 \\approx 2\\left(\n"
"1 + \\frac{1}{2}(-1/4) - \\frac{1}{8}(-1/4)^2 + \\frac{1}{16}(-1/4)^3 -\n"
"\\frac{5}{128}(-1/4)^4+\\cdots\n"
"\\right)$\n"
"\n"
"Taking just these five terms, the fraction on the right comes out to $28379/16384\\approx 1.73212$, which is impressively close to $\\sqrt3\\approx1.7320508$.\n"
"We got 3 decimal places of accuracy, nice!\n"
"\n"
"**SOCRATES:** Great! Now you see the power of Newton's Binomial Theorem. Ok, so then let's return all the way back to your original question, about Newton's estimate for $\\pi$.\n"
"\n"
"**SIMPLICIO:** Hmmm, $\\pi$ is the ratio of circumference to diameter in a circle. So where am I supposed to find a length.\n"
"\n"
"**SOCRATES:** Ah, but what did we learn from Archimedes?\n"
"\n"
"**SIMPLICIO:** Oh, that $\\pi$ is also an *area*, not just a length. It's the area of a unit circle $\\pi r^2$ where $r=1$.\n"
"\n"
"**SOCRATES:** Beautiful. And could you find a circle's area lurking somewhere?\n"
"\n"
"**SIMPLICIO:**  I think I see it! Thanks to Descartes, and \"Cartesian\" coordinates, we can express the  circle as the graph of $x^2+y^2=1$, or to make it a function, $y=\\sqrt{1-x^2}$. So we just have to replace $x$ in our series with $-x^2$.\n"
"\n"
"$\n"
"\\sqrt{1-x^2}\n"
"= 1 + \\frac{1}{2}(-x^2) - \\frac{1}{8}(-x^2)^2 + \\frac{1}{16}(-x^2)^3 - \\frac{5}{128}(-x^2)^4+\\cdots\n"
"$\n"
"\n"
"$\n"
"= 1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\n"
"$\n"
"\n"
"And the area under the curve $y=\\sqrt{1-x^2}$ from $x=0$ to $x=1$ is\n"
"a quarter circle.\n"
"[![Quarter Circle](images/PiOver4.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"\n"
"**SOCRATES:** Luckily, Newton had just invented calculus! So how else\n"
"could he compute the area under this curve?\n"
"\n"
"**SIMPLICIO:** With an integral! So:\n"
"\n"
"$\\frac{\\pi}4 = \\int_0^1 \\sqrt{1-x^2} \\, dx =\n"
"\\int_0^1 \\left(1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\\right) dx$\n"
"\n"
"I'll just integrate term by term,...\n"
"\n"
"**SOCRATES:** Whoa, hang on! Why are you allowed... You know what, nevermind, sorry.\n"
"Just go ahead.\n"
"\n"
"**SIMPLICIO:** Ok, weirdo. Anyway. So integrating term by term, I get:\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"$= 1 - \\frac{1}{6} - \\frac{1}{40} - \\frac{1}{112} - \\frac{5}{1152} - \\cdots $\n"
"\n"
"Wow! So Newton got an infinite series for $\\pi$!\n"
"If I evaluate just these five terms, and cross multiply by the factor of $4$, I get the fraction\n"
"$32057/10080\\approx 3.180$, not bad!\n"
"\n"
"**SOCRATES:** Not bad indeed. You know, Simplicio, many math papers have roughly zero new ideas; they're just\n"
"doing something nobody bothered to do before in a slightly\n"
"newer context. A really good math paper can have one or two genuinely new ideas. Newton is already on new idea number five, and he's still not done!\n"
"\n"
"**SIMPLICIO:** Ok, so what's new idea number six?\n"
"\n"
"**SOCRATES:** Well, remember how you integrated all the way up to $x=1$? In your series,\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"you have all these high powers of $x$ but they're being \"wasted\" because you're setting $x$ to $1$. What if instead  you only integrated up to, say, $x=1/2$?\n"
"\n"
"**SIMPLICIO:** Ooh, cool! Then the series will converge much more rapidly. But wait, that changes the geometry. Instead of a quarter-circle, we now have... a 30 degree sector, which has area $\\pi/12$, plus a 30-60-90 triangle -- ah that must be why you suggested $x=1/2$ -- with area $\\frac12\\times\\frac12\\times\\frac{\\sqrt3}2$.\n"
"\n"
"[![Integrating to x=1/2](images/PiOver12.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"Good thing we already know how to quickly estimate $\\sqrt3$ to high accuracy! (Ah, that's the trade-off: we could set $x$ even smaller, for faster convergence, but then we'll need to deal with ever more complicated geometric evaluations; so $x=1/2$ is a \"sweet spot\".) So now:\n"
"\n"
" $ \\frac{\\pi}{12} +  \\frac{\\sqrt3}8 =\n"
"\\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^{1/2}$\n"
"\n"
"$ = \\frac12 - \\frac{1}{6}\\left(\\frac12\\right)^3 - \\frac{1}{40}\\left(\\frac12\\right)^5 - \\frac{1}{112}\\left(\\frac12\\right)^7 - \\frac{5}{1152}\\left(\\frac12\\right)^9 - \\cdots.$\n"
"\n"
"Again evaluating just these five terms already gives the fraction $9874097/20643840$.\n"
"And now isolating $\\pi$ gives the estimate\n"
"\n"
"$\\pi \\approx 12\\times\\left(9874097/20643840 -  \\frac{\\sqrt3}8\\right) \\approx 3.14161,$\n"
"\n"
"which is off by two parts in $100,000$ from the true estimate $\\pi \\approx 3.14159$. All that with just five terms, amazing!\n"
"\n"
"\n"
"**SOCRATES:** Yes, Newton was very impressive indeed.\n"
"Here's a nice YouTube video by Veritasium that discusses this whole saga (right-click to get it to pop up in a new tab):\n"
"[![Veritasium Video](https://img.youtube.com/vi/gMlf1ELvRzc/maxresdefault.jpg)](https://youtu.be/gMlf1ELvRzc)\n"
"\n"
" In fact, a series for $\\pi$ similar to this one was discovered two centuries earlier, by the Indian mathematician Madhava of Sangamagrama.\n"
" And it would take two more centuries until mathematicians figured out how to rigorously justify Newton's work. To do so, they had to figure out:\n"
"\n"
"- What it meant for a sequence of real numbers $a_0, a_1, a_2,\\dots$ to converge?\n"
"- What it meant for a series (that is, sequence of partial sums) $a_0 + a_1 + a_2 +\\cdots$ to converge, and could we sum these numbers in any order we like,\n"
"- What it meant for a series involving a variable, like a power series $a_0 + a_1  x + a_2  x^2+\\cdots$ to converge, and if so, what kind of function it converged to,\n"
"- When can we interchange limits with integrals, like integrating term by term, $\\int(a_0 + a_1  x + a_2  x^2+)dx\\cdots \\overset{?}=\\int \\, a_0\\, dx+\\int \\, a_1  x\\, dx+\\int\\, a_2  x^2\\, dx+\\cdots$,\n"
"\n"
"Etc, etc. We have a lot of work to do!\n"
"\n"
"**SIMPLICIO:** Ok, ok; you've convinced me! On with some actual Real Analysis please."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ðŸŽ‰"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Write `apply h` since the hypothesis `h` is  what we want to prove."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "# Algebraic manipulations\n"
"\n"
"Now let's learn about algebraic simplification. Suppose you need to prove that $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$.\n"
"\n"
"This is true by the basic laws of algebra - expanding the left side using the distributive law, commutativity, associativity, etc. But doing this by hand would be extremely tedious.\n"
"\n"
"Fortunately, Lean has a powerful tactic called `ring_nf` (\"ring normal form\") that can automatically perform algebraic manipulations like:\n"
"- Expanding products\n"
"- Collecting like terms\n"
"- Rearranging using commutativity and associativity\n"
"- Applying the distributive law\n"
"\n"
"When you have an algebraic identity involving addition, subtraction, and multiplication, `ring_nf` can often prove it automatically.\n"
"\n"
"Try it out on this classic binomial expansion!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "This is where you might find it useful to call `norm_num` and normalize `|0|` to `0`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "Excellent! You've learned the `choose` tactic for working with existence in hypotheses.\n"
"\n"
"Notice the complete pattern:\n"
"1. `choose c hc using h` unpacked the hypothesis into a specific value `c` and proof `hc : f c = 2`\n"
"2. `use c` provided this same value as our witness for the goal\n"
"3. `rewrite [hc]` rewrote `f c` as `2` in the goal, changing it to `2^2 = 4`\n"
"4. `ring_nf` verified that `2 ^ 2 = 4`\n"
"\n"
"The symmetry is beautiful:\n"
"- `use` when you have `âˆƒ` in the goal (\"here's my specific example\")\n"
"- `choose` when you have `âˆƒ` in a hypothesis (\"let me unpack this existence claim\")\n"
"\n"
"This completes your basic logical toolkit! In real analysis, you'll use `obtain` constantly when working with:\n"
"- Limit definitions (\"given Îµ > 0, there exists Î´ > 0...\")\n"
"- Intermediate Value Theorem (\"there exists c such that f(c) = 0\")\n"
"- Existence theorems throughout analysis\n"
"\n"
"You're now ready to tackle real mathematical proofs!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "If a function of `x` always equals `xÂ²`, then it equals `tÂ²` when evaluated at `t`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "For all positive real numbers, this algebraic identity holds."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Every mathematical expression equals itself."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L2Pset.L2Pset1
msgid "Problem 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Write `use 42`, but with `42` replaced by the correct answer. Then how should you finish?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Type `rewrite [Bob]` to replace `x` with `2` in the goal. Then what?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The `ring_nf` tactic puts both sides of an equation into a standard algebraic form and checks if they're equal."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Use `intro Îµ` to introduce the variable, then `intro hÎµ` to introduce the hypothesis `Îµ > 0`. Then how do you solve the goal?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "Lecture 1: The Story of Real Analysis"
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
msgid "Find the correct constant."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "# Rewriting with equalities\n"
"\n"
"Now let's learn about rewriting. Suppose you have a hypothesis called `Bob : x = 2`, and your goal is to prove that `x + y = 2 + y`.\n"
"\n"
"Can you use `rfl`? No, because the two sides of the goal (`x + y` and `2 + y`) are not *identically* the same.\n"
"\n"
"Can you use `apply Bob`? No, because `Bob` says `x = 2`, which is not what the goal is asking for.\n"
"\n"
"But you can use the hypothesis `Bob` to *rewrite* the goal. Since `Bob` tells us that `x = 2`, we can replace `x` with `2` in our goal.\n"
"\n"
"In Lean, if you have a hypothesis which is an equality, and you want to replace the *left hand side* of that equality with the *right hand side* in your goal, you use the `rewrite` tactic. The syntax is:\n"
"\n"
"`rewrite [hypothesis_name]`\n"
"\n"
"Unfortunately, those square brackets are part of the Lean syntax, and there's nothing you or I can do about them right now. Just remember: `rewrite [Bob]` means \"use the equality in `Bob` to rewrite the goal.\"\n"
"\n"
"After you rewrite, you're not done. But you should know how to finish from there.\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Great! You've learned the `rewrite` tactic.\n"
"\n"
"Notice what happened: after you typed `rewrite [Bob]`, the goal changed from `x + y = 2 + y` to `2 + y = 2 + y`. Then you needed to type `rfl` to finish the proof, since both sides were now identical.\n"
"\n"
"So far you've learned:\n"
"- `apply hypothesis_name` when a hypothesis matches your goal\n"
"- `rfl` when you need to prove something equals itself\n"
"- `rewrite [hypothesis_name]` when you want to use an equality to rewrite your goal\n"
"\n"
"The `rewrite` tactic is incredibly powerful and you'll use it constantly in real analysis!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# ðŸŽ‰ Excellent Work! ðŸŽ‰\n"
"\n"
"You've just completed your first rigorous limit proof! Let's reflect on what you accomplished and the key insights from this foundational example.\n"
"\n"
"**What you just proved:**\n"
"You showed that if a sequence always outputs the same value `L`, then it converges to `L`. The Machinist's response to any tolerance demand `Îµ > 0` is beautifully simple: 'I can meet that specification immediately with any production run length `N`, because I'm already producing exactly what you want!'\n"
"\n"
"**Key Insights from this proof:**\n"
"\n"
"1. **The `change` tactic**: You learned how to unfold a definition to see what you're really trying to prove. `SeqLim a L` became the concrete epsilon-N condition.\n"
"\n"
"2. **The logical structure**: The proof followed the natural flow of the definition:\n"
"   - `intro Îµ hÎµ` handled 'for every Îµ > 0'\n"
"   - `use 1` provided the witness `N` (any number works!)\n"
"   - `intro n hn` handled 'âˆ€ n â‰¥ N'\n"
"   - Then algebraic manipulation showed that `|a n - L| = |L - L| = |0|`\n"
"   - Then numerical normalization gave that `|0| = 0`, and `hÎµ` finally proved that `|a n - L| < Îµ`.\n"
"\n"
"**The Beautiful Simplicity:**\n"
"This is the Machinist's dream scenarioâ€”no matter how demanding the engineer's tolerance requirements, the constant factory can satisfy them instantly. There's no trade-off between precision and effort because the output is already perfect!\n"
"\n"
"You're building the foundation for all of calculus. Every limit, derivative, and integral ultimately rests on arguments like this one.\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Let's step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If a sequence has the same value for every term, then it converges to that constant value.\n"
"\n"
"**Proof:** Suppose we have a sequence $a(n)$ where $a(n) = L$ for all $n$, and we want to show that this sequence converges to $L$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|a(n) - L| < \\varepsilon$.\n"
"\n"
"This is almost trivially simple: since $a(n) = L$ for every $n$, we have:\n"
"$$|a(n) - L| = |L - L| = |0| = 0$$\n"
"\n"
"Since $0 < \\varepsilon$ for any positive $\\varepsilon$, we can choose any $N$ we want (we chose $N = 1$ in the proof, but $N = 0$ or $N = 1000$ would work equally well).\n"
"\n"
"Therefore, for any $n \\geq N$, we have $|a(n) - L| = 0 < \\varepsilon$, which proves convergence.\n"
"**QED**"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The ring_nf tactic"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
msgid "Given that `f (u) = 2 * u + 1` for all `u`, prove that there exists some `a` such that `f (3) = a`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "# Proving existence\n"
"\n"
"Sometimes in mathematics, you need to prove that something exists. For example, suppose I wanted to ask you what the binomial coefficient in front of $x^2y^2$ is\n"
"in the expansion of $(x+y)^4$; how would I do it? Lean can't ask questions,\n"
"it can only prove theorems! So the way I would ask this is:\n"
"  prove that there exists a real number $c$ such that\n"
"\n"
"  $(x+y)^4 = x^4 + 4x^3y + cx^2y^2 + 4xy^3 + y^4$.\n"
"\n"
"  The way to prove that such a number\n"
"  exists is to exhibit it, that is, tell me which number to *use*,\n"
"  and then prove that that number indeed satisfies the equation.\n"
"\n"
"This is called an *existential statement*. In Lean, as in mathematics,\n"
"existence is written using `âˆƒ` (read: \"there exists\").\n"
"This symbol is called the *existential quantifier*, and is written in Lean by typing \\exists, that is, a backslash, then the word `exists`, and then a space.\n"
"So this goal would look in Lean like so:\n"
"\n"
"`âˆƒ (c : â„), (x + y)^4 = x^4 + 4*x^3*y + c*x^2*y^2 + 4*x*y^3 + y^4`\n"
"\n"
"To prove an existence statement, you need to provide a specific value that works. This is where the `use` tactic comes in.\n"
"\n"
"If you think you know what value of `c` would work, you can write `use 42` (or with `42` replaced by whatever number you think is right). Lean will then substitute that value and ask you to prove that the resulting equation is true.\n"
"\n"
"Try writing `use`, then a space, and then a number. Do you see what to do after that?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "If we know that $x = 2$, then we can prove that $x + y = 2 + y$."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "The `have` tactic has the following\n"
"syntax: `have NewHypothesisName (Assumptions) : Claim := by GiveTheProof`.\n"
"This creates a new hypothesis called\n"
"`NewHypothesisName : âˆ€ (Assumptions), ClaimHolds`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "# Using universal statements\n"
"\n"
"Now let's learn the flip side of `intro`. You have already learned that:\n"
"- if you have `âˆƒ` in the goal, you write `use` to provide a specific value. And\n"
"- if you have `âˆ€` in the goal, you write `intro` to introduce an arbitrary variable\n"
"\n"
"But what if you have `âˆ€` in a *hypothesis* and you want to use it for a particular value?\n"
"\n"
"For a concrete example, suppose you have:\n"
"- A positive real number `t`; that is, a real number `t`, together with a hypothesis, say, `t_pos` that `t > 0`\n"
"- A function `f : â„ â†’ â„`\n"
"- A hypothesis `hf : âˆ€ x > 0, f (x) = x^2`, meaning \"for all x positive, f (x) equals xÂ²\". (Note that you *have* to put a space after `f` before `(x)` or else Lean will be very angry with you! In fact, Lean will often drop unnecessary parentheses, so you'll see `f x` instead of `f (x)` -- and again, definitely *not* `f(x)`.)\n"
"- And you want to prove the goal `f (t) = t^2`.\n"
"\n"
"Can you use `apply hf`? No! The hypothesis `hf` says \"for all positive x, f (x) = xÂ²\" but the goal asks specifically about `f (t) = tÂ²`. They're not  the same.\n"
"\n"
"This is where the `specialize` command comes in. You can write `specialize hf t` to specialize the statement `hf` to the particular value `t`. This transforms `hf` from \"âˆ€ x > 0, f (x) = xÂ²\" into \"t > 0 â†’ f (t) = tÂ²\". Just like we had to `intro` multiple times (once for the dummy variable name, and again to name the hypothesis), we can specialize multiple times; so you can now write `specialize hf t_pos`. Or you can kill two birds with one stone via: `specialize hf t t_pos`.\n"
"\n"
"I'm sure you can solve the goal from there yourself!"
msgstr ""

#: Game.Levels.L2Pset.L2Pset2
msgid "# Problem 2\n"
"\n"
"Do the same for the exponent $3/2$. Find constants `c`, `d`, and `e` so that:\n"
"\n"
"$(1 + \\frac32 x + c \\cdot x^2 + d \\cdot x^3 + e \\cdot x^4)^2 - (1 + x) ^ 3$\n"
"\n"
"has only terms of degree five or higher.\n"
"\n"
"Hint: when you have multiple existential quantifiers, you can just write a single `use`\n"
"and separate the answers by a comma, like so: `use 6, 7, 42` (in place of: `use 6`, then `use 7`, then `use 42`)."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Excellent! You've learned the `rfl` tactic.\n"
"\n"
"The key difference:\n"
"- Use `apply hypothesis_name` when you have a hypothesis that matches your goal\n"
"- Use `rfl` when you need to prove that something equals itself\n"
"\n"
"These are two of the most fundamental tactics in Lean. As we progress through real analysis, you'll see that many complex proofs ultimately come down to showing that two expressions are identical."
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "Problem 5"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Perfect! You've learned the `use` tactic for existence proofs.\n"
"\n"
"Notice what happened:\n"
"1. `use 6` told Lean that $c = 6$ is our proposed value\n"
"2. The goal changed to proving $(x + y)^4 = x^4 + 4x^3y + 6x^2y^2 + 4xy^3 + y^4$\n"
"3. `ring_nf` verified that this algebraic identity is correct\n"
"\n"
"The `use` tactic is fundamental in real analysis. You'll need it to:\n"
"- Find specific values of $\\varepsilon$ and $\\delta$ in limit proofs\n"
"- Construct witnesses for existence theorems\n"
"- Provide counterexamples\n"
"\n"
"Your growing toolkit:\n"
"- `apply`, `rfl`, `rewrite` for basic equality reasoning\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for existence proofs"
msgstr ""
